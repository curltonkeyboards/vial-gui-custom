<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDIswitch Connect</title>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: 15px;
            background-color: #f8fafc;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        h1 {
            text-align: center;
            color: #1a202c;
            margin-bottom: 24px;
            font-size: 2rem;
            font-weight: 400;
        }
        
        .connection-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 18px;
            margin-bottom: 18px;
            text-align: center;
        }
        
        .connection-bar button {
            margin-top: 12px;
            margin-left: 0;
            margin-right: 0;
        }
        
        .status-display {
            display: flex;
            align-items: center;
            font-weight: 500;
            color: #2d3748;
        }
        
        .status-light {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
            transition: all 0.2s ease;
        }
        
        .status-light.connected {
            background-color: #48bb78;
            box-shadow: 0 0 8px rgba(72, 187, 120, 0.4);
        }
        
        .status-light.disconnected {
            background-color: #f56565;
            box-shadow: 0 0 8px rgba(245, 101, 101, 0.4);
        }
        
        button {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            margin: 8px;
            font-family: 'Inter', sans-serif;
        }
        
        button:hover {
            background: linear-gradient(135deg, #3182ce 0%, #2c5aa0 100%);
            transform: translateY(-1px);
        }
        
        button:disabled {
            background: #e2e8f0;
            color: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }
        
        .save-all-btn {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            font-size: 1rem;
            padding: 16px 32px;
            margin-bottom: 16px;
            width: 100%;
        }
        
        .save-all-btn:hover {
            background: linear-gradient(135deg, #1e40af 0%, #1d4ed8 100%);
        }
        
        .loop-manager {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 18px;
        }
        
        .loop-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 12px;
            margin-bottom: 18px;
        }
        
        .save-section, .load-section {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
        }
        
        .save-section {
            min-height: 240px; /* Reduced from 280px */
        }
        
        .load-section {
            min-height: 240px; /* Reduced from 280px */
        }
        
        .loop-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin: 12px 0;
        }
        
        .loop-btn {
            background: #e2e8f0;
            color: #4a5568;
            border: 2px solid #e2e8f0;
            padding: 12px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            text-align: center;
            transition: all 0.2s ease;
        }
        
        .loop-btn:hover {
            background: #cbd5e0;
            border-color: #cbd5e0;
        }
        
        .loop-btn.has-data {
            background: #4299e1;
            color: white;
            border-color: #4299e1;
        }
        
        .loop-btn.available {
            background: #48bb78;
            color: white;
            border-color: #48bb78;
            box-shadow: 0 0 10px rgba(72, 187, 120, 0.5);
        }
        
        .loop-btn.unavailable {
            background: #f56565;
            color: white;
            border-color: #f56565;
            opacity: 0.6;
        }
        
        .transfer-status {
            background: #ebf8ff;
            border: 1px solid #4299e1;
            border-radius: 6px;
            padding: 12px;
            margin: 16px 0;
            font-weight: 500;
            color: #2c5aa0;
            display: none;
        }
        
        .transfer-status.active {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 8px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #4299e1;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .error {
            background: #fed7d7;
            border: 1px solid #fc8181;
            color: #c53030;
            padding: 16px;
            border-radius: 8px;
            position: fixed;
            top: 10px;
            right: 20px;
            z-index: 10000;
            min-width: 300px;
            max-width: 500px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            animation: slideInRight 0.3s ease-out;
        }
        
        .success {
            background: #c6f6d5;
            border: 1px solid #68d391;
            color: #2f855a;
            padding: 16px;
            border-radius: 8px;
            position: fixed;
            top: 10px;
            right: 20px;
            z-index: 10000;
            min-width: 300px;
            max-width: 500px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            animation: slideInRight 0.3s ease-out;
        }
		
        /* ThruLoop Settings Button */
        .thruloop-settings-btn {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            margin: 16px auto 8px auto;
            display: block;
            width: 100%;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
        }

        .thruloop-settings-btn:hover {
            background: linear-gradient(135deg, #6d28d9 0%, #5b21b6 100%);
            transform: translateY(-1px);
        }

        /* ThruLoop Modal Styles */
        .thruloop-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .thruloop-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 90%;
            max-height: 90%;
            overflow-y: auto;
            z-index: 1001;
        }

        .thruloop-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 20px 10px 20px;
            border-bottom: 1px solid #ddd;
        }

        .thruloop-modal-title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin: 0;
        }

        .thruloop-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .thruloop-modal-close:hover {
            background-color: #f0f0f0;
            color: #000;
        }

        .thruloop-modal-body {
            padding: 20px;
        }

        .thruloop-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            position: relative;
        }
        
        .thruloop-settings-grid {
            display: grid;
            grid-template-columns: auto auto auto;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .thruloop-setting-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .thruloop-channel-label {
            font-size: 18px;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .thruloop-midi-channel-select {
            width: 120px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        
        .thruloop-label {
            font-weight: bold;
            white-space: nowrap;
        }
        
        .thruloop-container input[type="checkbox"] {
            margin-right: 8px;
        }
        
        .thruloop-container select, .thruloop-cc-select {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        
        .thruloop-cc-select {
            width: 90px;
            text-align: center;
        }
        
        .thruloop-main-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 0px;
        }
        
        .thruloop-main-table th {
            background-color: #f8f9fa;
            padding: 8px;
            text-align: center;
            border: 1px solid #ddd;
            font-weight: bold;
        }
        
        .thruloop-main-table td {
            padding: 8px;
            text-align: center;
            border: 1px solid #ddd;
            background-color: white;
        }
        
        .thruloop-main-table td:first-child {
            text-align: left;
            font-weight: bold;
            background-color: #f8f9fa;
        }
        
        #thruloopLoopchopTable td:first-child {
            text-align: center;
            font-weight: normal;
            background-color: white;
        }
        
        .thruloop-section-header {
            background-color: #e9ecef !important;
            font-weight: bold;
            text-align: center !important;
            color: #495057;
        }
        
        .thruloop-disabled-section {
            opacity: 0.2;
            pointer-events: none;
            position: relative;
        }
        
        .thruloop-disabled-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(128, 128, 128, 0.85);
            padding: 40px 80px;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
            font-size: 24px;
            font-weight: bold;
            color: white;
            z-index: 10;
            border: 3px solid #999;
            display: none;
        }
        
        .thruloop-button-group {
            text-align: center;
            margin-top: 20px;
        }
        
        .thruloop-btn {
            background-color: #007acc;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 10px;
            font-size: 16px;
        }
        
        .thruloop-btn:hover {
            background-color: #005a9e;
        }
        
        .thruloop-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .thruloop-status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
            display: none;
            text-align: center;
        }
        
        .thruloop-status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .thruloop-status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .file-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            margin: 16px 0;
        }
        
        .file-item {
            padding: 12px 16px;
            border-bottom: 1px solid #f1f5f9;
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }
        
        .file-item:hover {
            background: #f8fafc;
        }
        
        .file-item.selected {
            background: #ebf8ff;
            border-left: 4px solid #4299e1;
        }
        
        .file-info {
            flex: 1;
            min-width: 0;
        }
        
        .file-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-remove {
            background: #f56565;
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .file-remove:hover {
            background: #e53e3e;
            transform: scale(1.1);
        }
        
        /* Track Assignment Interface */
        .track-assignment {
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
            border-radius: 8px;
            padding: 16px;
            margin-top: 12px;
            display: none;
        }
        
        .track-assignment.active {
            display: block;
        }
        
        .track-assignment h4 {
            margin: 0 0 12px 0;
            color: #0c4a6e;
            font-size: 0.9rem;
        }
        
        .track-list {
            display: grid;
            gap: 8px;
        }
        
        .track-item {
            display: grid;
            grid-template-columns: 1fr auto auto auto;
            gap: 8px;
            align-items: center;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
        }
        
        .track-name {
            font-weight: 500;
            color: #374151;
            font-size: 0.85rem;
        }
        
        .track-select {
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.8rem;
            min-width: 80px;
        }
        
        .track-type {
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.8rem;
            min-width: 70px;
        }
        
        .track-type.disabled {
            background: #f3f4f6;
            color: #9ca3af;
            cursor: not-allowed;
        }
        
        .track-load-btn {
            padding: 4px 8px;
            font-size: 0.8rem;
            margin: 0;
            min-width: 60px;
        }
        
        /* Advanced Track Assignment Section */
        .advanced-track-section {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0 16px 0;
            display: none;
        }
        
        .advanced-track-section.visible {
            display: block;
        }
        
        .advanced-track-section h3 {
            margin: 0 0 20px 0;
            color: #1a202c;
            font-size: 1.25rem;
            font-weight: 500;
            text-align: center;
        }
        
        .track-selection-area {
            margin-bottom: 24px;
        }
        
        .track-selection-area h4 {
            margin: 0 0 12px 0;
            color: #4a5568;
            font-size: 1rem;
            font-weight: 500;
        }
        
        .track-buttons-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            background: white;
        }
        
        .track-selection-btn {
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0;
            font-size: 0.85rem;
        }
        
        .track-selection-btn:hover {
            background: #ebf8ff;
            border-color: #4299e1;
            transform: none;
        }
        
        .track-selection-btn.selected {
            background: #1e40af;
            border-color: #1e40af;
            color: white;
        }
        
        .track-selection-btn:disabled {
            background: #f3f4f6;
            color: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }
        
        .track-info {
            font-weight: 500;
            color: #374151;
        }
        
        .track-selection-btn.selected .track-info {
            color: white;
        }
        
        .track-details {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 4px;
        }
        
        .track-selection-btn.selected .track-details {
            color: #e5e7eb;
        }
        
        .loop-assignment-area h4 {
            margin: 0 0 16px 0;
            color: #4a5568;
            font-size: 1rem;
            font-weight: 500;
        }
        
        .assignment-buttons {
            display: block;
        }
        
        .assignment-section {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
        }
        
        .assignment-loop-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .assignment-btn {
            background: #e2e8f0;
            color: #4a5568;
            border: 2px solid #e2e8f0;
            padding: 12px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            text-align: center;
            transition: all 0.2s ease;
            font-size: 0.85rem;
        }
        
        .assignment-btn:hover:not(:disabled) {
            background: #cbd5e0;
            border-color: #cbd5e0;
        }
        
        .assignment-btn.available {
            background: #48bb78;
            color: white;
            border-color: #48bb78;
            box-shadow: 0 0 8px rgba(72, 187, 120, 0.3);
        }
        
        .assignment-btn.available:hover {
            background: #38a169;
            border-color: #38a169;
        }
        
        .assignment-btn:disabled {
            background: #e2e8f0;
            color: #9ca3af;
            border-color: #e2e8f0;
            cursor: not-allowed;
        }
        
        .assignment-info {
            margin-top: 12px;
            padding: 8px 12px;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 6px;
        }
        
        .advanced-options {
            margin-bottom: 16px;
        }
        
        .advanced-toggle-btn {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            font-family: 'Inter', sans-serif;
        }
        
        .advanced-toggle-btn:hover {
            background: linear-gradient(135deg, #047857 0%, #065f46 100%);
            transform: translateY(-1px);
        }
        
        .advanced-toggle-btn input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin: 0;
            pointer-events: none;
        }
        
        .debug {
            display: none; /* Hide debug box from UI - logs still go to console */
        }

        /* MIDI Patchbay Styles */
        .section {
            margin-bottom: 20px;
        }
        
        .section h2 {
            color: #2d3748;
            border-bottom: 2px solid #4299e1;
            padding-bottom: 6px;
            font-weight: 500;
        }
        
        .device-list {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            min-height: 80px;
        }
        
        .device {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            margin: 6px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }
        
        .device:hover {
            border-color: #cbd5e0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .device-name {
            font-weight: 500;
            color: #2d3748;
        }
        
        .connections {
            margin-top: 30px;
        }
        
        .connection {
            background: #ebf8ff;
            border: 1px solid #4299e1;
            border-radius: 6px;
            padding: 16px;
            margin: 10px 0;
            transition: all 0.2s ease;
        }
        
        .connection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .connection-info {
            display: flex;
            align-items: center;
            flex: 1;
        }
        
        .connection-buttons {
            display: flex;
            gap: 8px;
        }
        
        .advanced-btn {
            background: #718096;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
        }
        
        .advanced-btn:hover {
            background: #4a5568;
        }
        
        .advanced-btn.active {
            background: #2d3748;
        }
        
        .connection-advanced {
            margin-top: 16px;
            padding: 20px;
            border-top: 1px solid #bee3f8;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            display: none;
        }
        
        .connection-advanced.open {
            display: block;
        }
        
        .connection:hover {
            background: #bee3f8;
        }
        
        .connection-arrow {
            font-size: 16px;
            color: #4299e1;
            font-weight: 500;
        }
        
        .add-connection {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 0px 18px 10px 18px; /* top, right, bottom, left */
            text-align: center;
            margin-bottom: 24px;
        }
        
        .connection-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin: 16px 0;
        }
        
        .arrow {
            font-size: 16px;
            color: #4299e1;
            font-weight: 500;
        }
        
        .output-status {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            color: #2d3748;
            font-size: 1rem;
        }
        
        .status-light {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 6px;
            transition: all 0.2s ease;
        }
        
        .status-light.connected {
            background-color: #48bb78;
            box-shadow: 0 0 8px rgba(72, 187, 120, 0.4);
        }
        
        .status-light.disconnected {
            background-color: #f56565;
            box-shadow: 0 0 8px rgba(245, 101, 101, 0.4);
        }
        
        .usb-fix {
            background: #fffbeb;
            border: 2px solid #f6ad55;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
        }
        
        .usb-fix h3 {
            margin-top: 0;
            color: #c05621;
            font-weight: 500;
        }
        
        .usb-fix p {
            color: #744210;
            margin-bottom: 16px;
            font-weight: 400;
        }
        
        .usb-fix button {
            background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
            margin-right: 12px;
            border-radius: 8px;
        }
        
        .usb-fix button:hover {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
        }
        
        .connections-section {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        
        .connections-title {
            color: #2d3748;
            font-size: 1.25rem;
            font-weight: 500;
            margin-bottom: 16px;
            border-bottom: 2px solid #4299e1;
            padding-bottom: 6px;
        }
        
        .filter-section {
            margin-bottom: 20px;
        }
        
        .filter-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
            font-weight: 500;
            color: #2d3748;
        }
        
        .filter-checkbox input {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .message-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
            gap: 8px;
            margin-top: 16px;
        }
        
        .message-type-btn {
            background: #e2e8f0;
            color: #4a5568;
            border: 2px solid #e2e8f0;
            padding: 10px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 500;
            text-align: center;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .message-type-btn:hover {
            background: #cbd5e0;
            border-color: #cbd5e0;
        }
        
        .message-type-btn.active {
            background: #4299e1;
            color: white;
            border-color: #4299e1;
        }
        
        .channel-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 6px;
            margin-top: 12px;
        }
        
        .channel-btn {
            background: #e2e8f0;
            color: #4a5568;
            border: 2px solid #e2e8f0;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
            text-align: center;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            min-height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .channel-btn:hover {
            background: #cbd5e0;
            border-color: #cbd5e0;
        }
        
        .channel-btn.active {
            background: #4299e1;
            color: white;
            border-color: #4299e1;
        }
        
        select {
            padding: 10px 14px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            margin: 0 10px;
            font-size: 0.85rem;
            color: #4a5568;
            background: white;
            transition: border-color 0.2s ease;
            min-width: 180px;
            font-family: 'Inter', sans-serif;
            font-weight: 400;
        }
        
        select:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
            border-radius: 6px;
        }

        /* Floating Progress Bar */
        .floating-progress {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #4299e1;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            z-index: 9999;
            min-width: 320px;
            text-align: center;
            backdrop-filter: blur(5px);
            display: none;
        }

        .floating-progress.active {
            display: block;
        }

        .floating-progress h3 {
            margin: 0 0 16px 0;
            color: #1a202c;
            font-size: 1.1rem;
            font-weight: 500;
        }

        .floating-progress-bar {
            width: 100%;
            height: 12px;
            background: #e2e8f0;
            border-radius: 6px;
            margin: 16px 0;
            overflow: hidden;
        }

        .floating-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4299e1 0%, #3182ce 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 6px;
        }

        .floating-progress-text {
            color: #4a5568;
            font-size: 0.9rem;
            margin-top: 8px;
        }

        .floating-progress-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            border-top-color: #4299e1;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
		.keyboard-settings-btn {
			background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
			color: white;
			border: none;
			padding: 16px 32px;
			border-radius: 6px;
			cursor: pointer;
			font-size: 1rem;
			font-weight: 500;
			margin: 8px auto 8px auto;
			display: block;
			width: 100%;
			transition: all 0.2s ease;
			font-family: 'Inter', sans-serif;
		}

		.keyboard-settings-btn:hover {
			background: linear-gradient(135deg, #b91c1c 0%, #991b1b 100%);
			transform: translateY(-1px);
		}

		.keyboard-modal-overlay {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.5);
			z-index: 1000;
		}

		.keyboard-modal {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: white;
			border-radius: 8px;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
			max-width: 1400px;
			width: 95%;
			max-height: 95%;
			overflow-y: auto;
			z-index: 1001;
		}

		.keyboard-modal-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 20px 20px 10px 20px;
			border-bottom: 1px solid #ddd;
		}

		.keyboard-modal-title {
			font-size: 24px;
			font-weight: bold;
			color: #333;
			margin: 0;
		}

		.keyboard-modal-close {
			background: none;
			border: none;
			font-size: 24px;
			cursor: pointer;
			color: #666;
			padding: 0;
			width: 30px;
			height: 30px;
			display: flex;
			align-items: center;
			justify-content: center;
			border-radius: 4px;
		}

		.keyboard-modal-close:hover {
			background-color: #f0f0f0;
			color: #000;
		}

		.keyboard-modal-body {
			padding: 20px;
		}

		/* Keyboard Settings Content Styles */
		.keyboard-container {
			background: white;
			padding: 20px;
			border-radius: 8px;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
			margin-bottom: 20px;
		}

		.keyboard-settings-grid {
			display: grid;
			grid-template-columns: 300px 1fr;
			gap: 20px;
			margin-bottom: 20px;
		}

		.keyboard-left-column {
			display: grid;
			grid-template-rows: auto;
			gap: 15px;
		}

		.keyboard-keysplit-section {
			display: grid;
			grid-template-columns: 1fr;
			gap: 15px;
		}

		.keyboard-keysplit-modes-box {
			border: 1px solid #ddd;
			border-radius: 6px;
			padding: 15px;
			background-color: #fafafa;
			text-align: center;
			margin-bottom: 20px;
		}

		.keyboard-keysplit-modes-row {
			display: grid;
			grid-template-columns: 1fr 1fr 1fr;
			gap: 15px;
		}

		.keyboard-keysplit-modes-row .keyboard-setting-item {
			display: grid;
			grid-template-columns: 80px auto;
			gap: 8px;
			justify-items: start;
			align-items: center;
		}

		.keyboard-keysplit-modes-row .keyboard-setting-item label {
			text-align: right;
			width: 100%;
			font-size: 13px;
		}

		.keyboard-keysplit-modes-row .keyboard-setting-item select {
			width: 120px;
			font-size: 12px;
		}

		.keyboard-keysplit-settings {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 20px;
		}

		.keyboard-setting-group {
			border: 1px solid #ddd;
			border-radius: 6px;
			padding: 15px;
			background-color: #fafafa;
		}

		.keyboard-setting-group.compact {
			padding: 12px;
		}

		.keyboard-setting-group h3 {
			margin: 0 0 12px 0;
			color: #333;
			font-size: 16px;
			border-bottom: 1px solid #ddd;
			padding-bottom: 8px;
			text-align: center;
		}

		.keyboard-keysplit-modes-box h3 {
			margin: 0 0 12px 0;
			color: #333;
			font-size: 16px;
			border-bottom: 1px solid #ddd;
			padding-bottom: 8px;
			text-align: center;
		}

		.keyboard-setting-item {
			display: flex;
			justify-content: center;
			align-items: center;
			margin-bottom: 6px;
			gap: 15px;
		}

		.keyboard-setting-item.aligned {
			display: grid;
			grid-template-columns: 140px auto;
			gap: 15px;
			justify-items: start;
			align-items: center;
		}

		.keyboard-setting-item.aligned label {
			text-align: right;
			width: 100%;
		}

		.keyboard-setting-item.aligned select {
			width: 100px;
		}

		.keyboard-setting-item:last-child {
			margin-bottom: 0;
		}

		.keyboard-setting-item label {
			font-weight: bold;
			font-size: 14px;
			color: #555;
			margin-right: 10px;
		}

		.keyboard-setting-item select {
			padding: 4px 8px;
			border: 1px solid #ccc;
			border-radius: 3px;
			min-width: 80px;
			text-align: center;
		}

		.keyboard-setting-item input[type="checkbox"] {
			transform: scale(1.2);
		}

		.keyboard-button-group {
			text-align: center;
			margin-top: 20px;
		}

		.keyboard-button-row {
			display: grid;
			gap: 8px;
			margin-bottom: 10px;
			max-width: 1000px;
			margin-left: auto;
			margin-right: auto;
		}

		.keyboard-default-buttons {
			grid-template-columns: repeat(5, 1fr);
		}

		.keyboard-slot-save-buttons {
			grid-template-columns: repeat(4, 1fr);
			max-width: 600px;
		}
		

		.keyboard-slot-load-buttons {
			grid-template-columns: repeat(4, 1fr);
			max-width: 600px;
		}

		.keyboard-button-row button {
			padding: 8px 12px;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 13px;
			font-weight: 500;
			transition: all 0.2s ease;
			min-height: 36px;
			white-space: nowrap;
			text-overflow: ellipsis;
			overflow: hidden;
			color: white;
		}

		.keyboard-button-row button:hover {
			transform: translateY(-1px);
			box-shadow: 0 3px 6px rgba(0,0,0,0.15);
		}

		.keyboard-button-row button:active {
			transform: translateY(0);
		}

		.keyboard-button-row button:disabled {
			background-color: #ccc !important;
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}

		.keyboard-default-btn {
			background-color: #6f42c1;
			padding: 12px 16px;
			min-height: 48px;
			font-size: 14px;
		}

		.keyboard-default-btn:hover:not(:disabled) {
			background-color: #5a32a3;
		}

		.keyboard-save-preset-btn {
			background-color: #28a745;
		}

		.keyboard-save-preset-btn:hover:not(:disabled) {
			background-color: #218838;
		}

		.keyboard-load-preset-btn {
			background-color: #6c757d;
		}

		.keyboard-load-preset-btn:hover:not(:disabled) {
			background-color: #5a6268;
		}

		.keyboard-file-btn {
			background-color: #fd7e14;
		}

		.keyboard-file-btn:hover:not(:disabled) {
			background-color: #e8650e;
		}
		
		.keyboard-reset-btn {
			background-color: #dc2626;
		}

		.keyboard-reset-btn:hover:not(:disabled) {
			background-color: #b91c1c;
		}
		.keyboard-status {
			margin-top: 15px;
			padding: 10px;
			border-radius: 4px;
			display: none;
			text-align: center;
			font-weight: 500;
			font-size: 14px;
		}

		.keyboard-status.success {
			background-color: #d4edda;
			color: #155724;
			border: 1px solid #c3e6cb;
		}

		.keyboard-status.error {
			background-color: #f8d7da;
			color: #721c24;
			border: 1px solid #f5c6cb;
		}

		/* Responsive adjustments for keyboard modal */
		@media (max-width: 768px) {
			.keyboard-settings-grid {
				grid-template-columns: 1fr;
			}
			
			.keyboard-left-column {
				grid-template-rows: auto;
			}
			
			.keyboard-keysplit-settings {
				grid-template-columns: 1fr;
			}
			
			.keyboard-keysplit-modes-row {
				grid-template-columns: 1fr;
				gap: 8px;
			}
			
			.keyboard-default-buttons, .keyboard-slot-save-buttons, .keyboard-slot-load-buttons {
				grid-template-columns: 1fr;
			}
			
			.keyboard-button-row button {
				min-height: 40px;
				font-size: 14px;
			}
		}

		@media (min-width: 769px) and (max-width: 1024px) {
			.keyboard-default-buttons {
				grid-template-columns: repeat(3, 1fr);
			}
			
			.keyboard-slot-save-buttons, .keyboard-slot-load-buttons {
				grid-template-columns: repeat(2, 1fr);
			}
			
			.keyboard-keysplit-modes-row {
				grid-template-columns: 1fr 1fr 1fr;
			}
		}

        .load-all-section {
            border-top: 2px solid #e2e8f0;
            margin-top: auto; /* Push to bottom of flex container */
            padding-top: 24px;
        }

        .load-all-btn {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            font-size: 1rem;
            padding: 16px 32px;
            margin-bottom: 16px;
            width: 100%;
        }

        .load-all-btn:hover {
            background: linear-gradient(135deg, #047857 0%, #065f46 100%);
        }

        .load-all-btn:disabled {
            background: #e2e8f0;
            color: #a0aec0;
        }

        /* Smooth transitions for button highlighting */
        .load-all-btn, .loop-btn {
            transition: all 0.3s ease;
        }
        
        /* Assignment buttons can have track-style appearance */
        .assignment-btn.track-style {
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            text-align: center;
            font-size: 0.85rem;
            padding: 12px;
        }
        
        .assignment-btn.track-style:hover:not(:disabled) {
            background: #ebf8ff;
            border-color: #4299e1;
        }
        
        .assignment-btn.track-style.selected {
            background: #1e40af;
            border-color: #1e40af;
            color: white;
        }
        
        .assignment-btn.track-style .track-info {
            font-weight: 500;
            color: #374151;
        }
        
        .assignment-btn.track-style.selected .track-info {
            color: white;
        }
        
        .assignment-btn.track-style .track-details {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 4px;
        }
        
        .assignment-btn.track-style.selected .track-details {
            color: #e5e7eb;
        }
        
        .remove-indicator {
            display: inline-block;
            background-color: #dc2626;
            color: white;
            width: 16px;
            height: 16px;
            border-radius: 3px;
            text-align: center;
            line-height: 16px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 6px;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MIDIswitch Connect </h1>
        
        <div id="status"></div>
        
        <!-- MIDI Patchbay Section -->
        <div class="section">       
            <div class="add-connection">
                <h3>Connect MIDI Devices to MIDIswitch</h3>
                <div class="connection-row">
                    <select id="inputSelect" onchange="addMIDIConnection()">
                        <option value="">Select MIDI Input...</option>
                    </select>
                    <span class="arrow">â†’</span>
                    <div class="output-status">
                        MIDIswitch <div class="status-light disconnected" id="statusLight"></div>
                    </div>
                </div>
            </div>
            
            <div class="connections-section">
                <div id="connectionsList"></div>
            </div>
            
            <div class="usb-fix" id="usbFix" style="display: none;">
                <h3>USB Device Not Detected?</h3>
                <p>If your MIDISwitch isn't showing up:</p>
                <button onclick="connectHID()" style="background: #4299e1;">Connect HID</button>
                <button onclick="hardRefresh()" style="background: #ff9800;">Force USB Device Scan</button>
                <button onclick="reinitializeMIDI()" style="background: #f44336;">Reinitialize MIDI System</button>
            </div>
        </div>
        
        <!-- Connection Status Bar -->
        <div class="connection-bar">
            <div class="status-display">
                <span id="statusText">MIDIswitch Disconnected</span> <div class="status-light disconnected" id="hidStatusLight"></div>
            </div>
            <button onclick="ensureConnection()" id="connectBtn">Connect Device</button>
        </div>
        
        <!-- Loop Manager Section -->
        <div class="loop-manager" id="loopManager" style="display: none;"> 
            <div class="loop-actions">
                <!-- Save Section -->
                <div class="save-section">
                    <div style="margin-bottom: 12px;">
                        <label style="font-weight: 500; margin-right: 8px;">Save Format:</label>
                        <select id="saveFormat" style="padding: 8px; border-radius: 4px; border: 2px solid #e2e8f0; font-size: 0.9rem;">
                            <option value="loop">.loop file (Fast)</option>
                            <option value="midi">.MIDI file</option>
                        </select>
                    </div>
                    <button class="save-all-btn" onclick="saveAllLoopsDirectly()">Save All Loops</button>
                    <p>Save individual loops:</p>
                    <div class="loop-buttons">
                        <button class="loop-btn" onclick="requestSaveLoop(1)">Loop 1</button>
                        <button class="loop-btn" onclick="requestSaveLoop(2)">Loop 2</button>
                        <button class="loop-btn" onclick="requestSaveLoop(3)">Loop 3</button>
                        <button class="loop-btn" onclick="requestSaveLoop(4)">Loop 4</button>
                    </div>
					<button class="keyboard-settings-btn" onclick="openKeyboardModal()">Keyboard Settings</button>
					 <button class="thruloop-settings-btn" onclick="openThruLoopModal()">ThruLoop Settings</button>
                    <div class="transfer-status" id="saveStatus">
                        <div>Receiving loop data...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="saveProgress"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Load Section -->
                <div class="load-section">                    
                    <!-- Browse Section -->
                    <button class="save-all-btn" onclick="browseFiles()">Load Loop</button>
                    <div class="file-list" id="fileList">
                        <div style="padding: 20px; text-align: center; color: #718096;">
                            No MIDI files loaded
                        </div>
                    </div>
                    
                    <!-- Load All Section -->
                    <div class="load-all-section">
                        <button class="load-all-btn" onclick="loadAllLoopsToDevice()" id="loadAllBtn" disabled>Load All Tracks to Device</button>
                        
                        <!-- Advanced Options -->
                        <div class="advanced-options">
                            <button class="advanced-toggle-btn" onclick="toggleAdvancedOptions()">
                                <input type="checkbox" id="showAdvanced">
                                <span>Show Advanced Track Assignment</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="transfer-status" id="loadStatus">
                        <div>Sending loop data...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="loadProgress"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Advanced Track Assignment Section -->
        <div class="advanced-track-section" id="advancedTrackSection">
            
            <!-- Track Selection -->
            <div class="track-selection-area" id="trackSelectionArea">
                <h4>Select Track:</h4>
                <div class="track-buttons-grid" id="trackButtonsGrid">
                    <div style="padding: 20px; text-align: center; color: #718096; font-style: italic;">
                        Select a multi-track MIDI file to see track options
                    </div>
                </div>
            </div>
            
            <!-- Loop Assignment -->
            <div class="loop-assignment-area" id="loopAssignmentArea" style="display: none;">
                <h4>Assign to Loop:</h4>
                <div class="assignment-buttons">
                    <div class="assignment-section">
                        <div class="assignment-loop-buttons">
                            <button class="assignment-btn" onclick="assignSelectedTrack(1, false)" id="assignMain1">Loop 1</button>
                            <button class="assignment-btn" onclick="assignSelectedTrack(2, false)" id="assignMain2">Loop 2</button>
                            <button class="assignment-btn" onclick="assignSelectedTrack(3, false)" id="assignMain3">Loop 3</button>
                            <button class="assignment-btn" onclick="assignSelectedTrack(4, false)" id="assignMain4">Loop 4</button>
                        </div>
                        <div class="assignment-loop-buttons">
                            <button class="assignment-btn" onclick="assignSelectedTrack(1, true)" id="assignOverdub1" disabled>Loop 1</button>
                            <button class="assignment-btn" onclick="assignSelectedTrack(2, true)" id="assignOverdub2" disabled>Loop 2</button>
                            <button class="assignment-btn" onclick="assignSelectedTrack(3, true)" id="assignOverdub3" disabled>Loop 3</button>
                            <button class="assignment-btn" onclick="assignSelectedTrack(4, true)" id="assignOverdub4" disabled>Loop 4</button>
                        </div>
                    </div>
                </div>
                
                <!-- Load Assignments Button -->
                <div style="margin-top: 20px;">
                    <button class="load-all-btn" onclick="loadAssignedTracksToDevice()" id="loadAssignmentsBtn" disabled>Load Tracks to Device</button>
                </div>
            </div>
        </div>
        
        <!-- ThruLoop Modal -->
        <div id="thruloopModalOverlay" class="thruloop-modal-overlay" onclick="closeThruLoopModal()">
            <div class="thruloop-modal" onclick="event.stopPropagation()">
                <div class="thruloop-modal-header">
                    <h2 class="thruloop-modal-title">ThruLoop Configuration</h2>
                    <button class="thruloop-modal-close" onclick="closeThruLoopModal()">&times;</button>
                </div>
                <div class="thruloop-modal-body">
                    <div class="thruloop-container">
                        <div class="thruloop-settings-grid">
                            <div class="thruloop-setting-item">
                                <span class="thruloop-channel-label">ThruLoop Channel</span>
                                <select id="thruloopLoopChannel" class="thruloop-midi-channel-select">
                                    <option value="1">Channel 1</option>
                                    <option value="2">Channel 2</option>
                                    <option value="3">Channel 3</option>
                                    <option value="4">Channel 4</option>
                                    <option value="5">Channel 5</option>
                                    <option value="6">Channel 6</option>
                                    <option value="7">Channel 7</option>
                                    <option value="8">Channel 8</option>
                                    <option value="9">Channel 9</option>
                                    <option value="10">Channel 10</option>
                                    <option value="11">Channel 11</option>
                                    <option value="12">Channel 12</option>
                                    <option value="13">Channel 13</option>
                                    <option value="14">Channel 14</option>
                                    <option value="15">Channel 15</option>
                                    <option value="16" selected>Channel 16</option>
                                </select>
                            </div>
                            <div class="thruloop-setting-item">
                                <label class="thruloop-label">
                                    <input type="checkbox" id="thruloopSyncMidi"> Send Restart Messages
                                </label>
                            </div>
                            <div class="thruloop-setting-item">
                                <label class="thruloop-label">
                                    <input type="checkbox" id="thruloopAlternateRestart"> Alternate Restart Mode
                                </label>
                            </div>
							<div class="thruloop-setting-item">
							<label class="thruloop-label">
								<input type="checkbox" id="thruloopCcLoopRecording"> CC Loop Recording
							</label>
						</div>
                        </div>
                        <div style="margin-top: 15px;">
                            <label class="thruloop-label">
                                <input type="checkbox" id="thruloopLoopEnabled"> Disable ThruLoop
                            </label>
                        </div>
                    </div>

                    <div class="thruloop-container" id="thruloopMainSection">
                        <div id="thruloopDisabledOverlay" class="thruloop-disabled-overlay">Enable ThruLoop to change</div>
                        <table class="thruloop-main-table">
                            <thead>
                                <tr>
                                    <th>Function</th>
                                    <th>Loop 1</th>
                                    <th>Loop 2</th>
                                    <th>Loop 3</th>
                                    <th>Loop 4</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Start Recording</td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStartRec1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStartRec2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStartRec3"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStartRec4"></select></td>
                                </tr>
                                <tr>
                                    <td>Stop Recording</td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStopRec1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStopRec2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStopRec3"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStopRec4"></select></td>
                                </tr>
                                <tr>
                                    <td>Start Playing</td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStartPlay1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStartPlay2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStartPlay3"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStartPlay4"></select></td>
                                </tr>
                                <tr>
                                    <td>Stop Playing</td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStopPlay1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStopPlay2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStopPlay3"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainStopPlay4"></select></td>
                                </tr>
                                <tr>
                                    <td>Clear</td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainClear1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainClear2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainClear3"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopMainClear4"></select></td>
                                </tr>
                                <tr>
                                    <td>Restart</td>
                                    <td><select class="thruloop-cc-select" id="thruloopRestart1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopRestart2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopRestart3"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopRestart4"></select></td>
                                </tr>
                                
                                <!-- Overdub Functions -->
                                <tr>
                                    <td class="thruloop-section-header" colspan="5">Overdub Functions</td>
                                </tr>
                                <tr>
                                    <td>Overdub Start Recording</td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStartRec1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStartRec2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStartRec3"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStartRec4"></select></td>
                                </tr>
                                <tr>
                                    <td>Overdub Stop Recording</td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStopRec1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStopRec2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStopRec3"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStopRec4"></select></td>
                                </tr>
                                <tr>
                                    <td>Overdub Start Playing</td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStartPlay1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStartPlay2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStartPlay3"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStartPlay4"></select></td>
                                </tr>
                                <tr>
                                    <td>Overdub Stop Playing</td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStopPlay1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStopPlay2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStopPlay3"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubStopPlay4"></select></td>
                                </tr>
                                <tr>
                                    <td>Overdub Clear</td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubClear1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubClear2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubClear3"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopOverdubClear4"></select></td>
                                </tr>
                                
                                <!-- LoopChop Section -->
                                <tr>
                                    <td class="thruloop-section-header" colspan="5">LoopChop</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <!-- Single LoopChop CC (when separate CC is unchecked) -->
                        <table class="thruloop-main-table" id="thruloopLoopchopSingle">
                            <tbody>
                                <tr>
                                    <td>Loop Chop</td>
                                    <td><select class="thruloop-cc-select" id="thruloopMasterCC"></select></td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <!-- Individual LoopChop CCs (when separate CC is checked) -->
                        <table class="thruloop-main-table" id="thruloopLoopchopTable">
                            <thead>
                                <tr>
                                    <th>0/8</th>
                                    <th>1/8</th>
                                    <th>2/8</th>
                                    <th>3/8</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><select class="thruloop-cc-select" id="thruloopNav0"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopNav1"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopNav2"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopNav3"></select></td>
                                </tr>
                                <tr>
                                    <th>4/8</th>
                                    <th>5/8</th>
                                    <th>6/8</th>
                                    <th>7/8</th>
                                </tr>
                                <tr>
                                    <td><select class="thruloop-cc-select" id="thruloopNav4"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopNav5"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopNav6"></select></td>
                                    <td><select class="thruloop-cc-select" id="thruloopNav7"></select></td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <!-- Checkbox moved below tables -->
                        <div style="margin-top: 15px;">
                            <label class="thruloop-label">
                                <input type="checkbox" id="thruloopSeparateLoopChopCC"> Separate CCs for LoopChop
                            </label>
                        </div>
                    </div>

                    <div class="thruloop-container thruloop-button-group">
                        <button class="thruloop-btn" id="thruloopSendAllBtn">Save Configuration</button>
                        <button class="thruloop-btn" id="thruloopLoadBtn">Load from Keyboard</button>
                        <button class="thruloop-btn" id="thruloopSaveFileBtn">Save to File</button>
                        <input type="file" id="thruloopLoadFileInput" accept=".json" style="display: none;">
                        <button class="thruloop-btn" id="thruloopLoadFileBtn">Load from File</button>
                        <div id="thruloopSendStatus" class="thruloop-status"></div>
                    </div>
                </div>
            </div>
        </div>
		<!-- Keyboard Settings Modal -->
		<div id="keyboardModalOverlay" class="keyboard-modal-overlay" onclick="closeKeyboardModal()">
			<div class="keyboard-modal" onclick="event.stopPropagation()">
				<div class="keyboard-modal-header">
					<h2 class="keyboard-modal-title">Keyboard Settings</h2>
					<button class="keyboard-modal-close" onclick="closeKeyboardModal()">&times;</button>
				</div>
				<div class="keyboard-modal-body">
					<div class="keyboard-container">
						<!-- Basic Settings - Full Width -->
						<div class="keyboard-keysplit-modes-box">
							<h3>Basic Settings</h3>
							<div class="keyboard-keysplit-modes-row">
								<div class="keyboard-setting-item">
									<label>Transpose:</label>
									<select id="keyboardTransposeNumber">
										<option value="-64">-64</option>
										<option value="-63">-63</option>
										<option value="-62">-62</option>
										<option value="-61">-61</option>
										<option value="-60">-60</option>
										<option value="-59">-59</option>
										<option value="-58">-58</option>
										<option value="-57">-57</option>
										<option value="-56">-56</option>
										<option value="-55">-55</option>
										<option value="-54">-54</option>
										<option value="-53">-53</option>
										<option value="-52">-52</option>
										<option value="-51">-51</option>
										<option value="-50">-50</option>
										<option value="-49">-49</option>
										<option value="-48">-48</option>
										<option value="-47">-47</option>
										<option value="-46">-46</option>
										<option value="-45">-45</option>
										<option value="-44">-44</option>
										<option value="-43">-43</option>
										<option value="-42">-42</option>
										<option value="-41">-41</option>
										<option value="-40">-40</option>
										<option value="-39">-39</option>
										<option value="-38">-38</option>
										<option value="-37">-37</option>
										<option value="-36">-36</option>
										<option value="-35">-35</option>
										<option value="-34">-34</option>
										<option value="-33">-33</option>
										<option value="-32">-32</option>
										<option value="-31">-31</option>
										<option value="-30">-30</option>
										<option value="-29">-29</option>
										<option value="-28">-28</option>
										<option value="-27">-27</option>
										<option value="-26">-26</option>
										<option value="-25">-25</option>
										<option value="-24">-24</option>
										<option value="-23">-23</option>
										<option value="-22">-22</option>
										<option value="-21">-21</option>
										<option value="-20">-20</option>
										<option value="-19">-19</option>
										<option value="-18">-18</option>
										<option value="-17">-17</option>
										<option value="-16">-16</option>
										<option value="-15">-15</option>
										<option value="-14">-14</option>
										<option value="-13">-13</option>
										<option value="-12">-12</option>
										<option value="-11">-11</option>
										<option value="-10">-10</option>
										<option value="-9">-9</option>
										<option value="-8">-8</option>
										<option value="-7">-7</option>
										<option value="-6">-6</option>
										<option value="-5">-5</option>
										<option value="-4">-4</option>
										<option value="-3">-3</option>
										<option value="-2">-2</option>
										<option value="-1">-1</option>
										<option value="0" selected>0</option>
										<option value="1">+1</option>
										<option value="2">+2</option>
										<option value="3">+3</option>
										<option value="4">+4</option>
										<option value="5">+5</option>
										<option value="6">+6</option>
										<option value="7">+7</option>
										<option value="8">+8</option>
										<option value="9">+9</option>
										<option value="10">+10</option>
										<option value="11">+11</option>
										<option value="12">+12</option>
										<option value="13">+13</option>
										<option value="14">+14</option>
										<option value="15">+15</option>
										<option value="16">+16</option>
										<option value="17">+17</option>
										<option value="18">+18</option>
										<option value="19">+19</option>
										<option value="20">+20</option>
										<option value="21">+21</option>
										<option value="22">+22</option>
										<option value="23">+23</option>
										<option value="24">+24</option>
										<option value="25">+25</option>
										<option value="26">+26</option>
										<option value="27">+27</option>
										<option value="28">+28</option>
										<option value="29">+29</option>
										<option value="30">+30</option>
										<option value="31">+31</option>
										<option value="32">+32</option>
										<option value="33">+33</option>
										<option value="34">+34</option>
										<option value="35">+35</option>
										<option value="36">+36</option>
										<option value="37">+37</option>
										<option value="38">+38</option>
										<option value="39">+39</option>
										<option value="40">+40</option>
										<option value="41">+41</option>
										<option value="42">+42</option>
										<option value="43">+43</option>
										<option value="44">+44</option>
										<option value="45">+45</option>
										<option value="46">+46</option>
										<option value="47">+47</option>
										<option value="48">+48</option>
										<option value="49">+49</option>
										<option value="50">+50</option>
										<option value="51">+51</option>
										<option value="52">+52</option>
										<option value="53">+53</option>
										<option value="54">+54</option>
										<option value="55">+55</option>
										<option value="56">+56</option>
										<option value="57">+57</option>
										<option value="58">+58</option>
										<option value="59">+59</option>
										<option value="60">+60</option>
										<option value="61">+61</option>
										<option value="62">+62</option>
										<option value="63">+63</option>
										<option value="64">+64</option>
									</select>
								</div>
								
								<div class="keyboard-setting-item">
									<label>Channel:</label>
									<select id="keyboardChannelNumber">
										<option value="0">1</option>
										<option value="1">2</option>
										<option value="2">3</option>
										<option value="3">4</option>
										<option value="4">5</option>
										<option value="5">6</option>
										<option value="6">7</option>
										<option value="7">8</option>
										<option value="8">9</option>
										<option value="9">10</option>
										<option value="10">11</option>
										<option value="11">12</option>
										<option value="12">13</option>
										<option value="13">14</option>
										<option value="14">15</option>
										<option value="15">16</option>
									</select>
								</div>
								
								<div class="keyboard-setting-item">
									<label>Velocity:</label>
									<select id="keyboardVelocityNumber">
										<option value="1">1</option>
										<option value="2">2</option>
										<option value="3">3</option>
										<option value="4">4</option>
										<option value="5">5</option>
										<option value="6">6</option>
										<option value="7">7</option>
										<option value="8">8</option>
										<option value="9">9</option>
										<option value="10">10</option>
										<option value="11">11</option>
										<option value="12">12</option>
										<option value="13">13</option>
										<option value="14">14</option>
										<option value="15">15</option>
										<option value="16">16</option>
										<option value="17">17</option>
										<option value="18">18</option>
										<option value="19">19</option>
										<option value="20">20</option>
										<option value="21">21</option>
										<option value="22">22</option>
										<option value="23">23</option>
										<option value="24">24</option>
										<option value="25">25</option>
										<option value="26">26</option>
										<option value="27">27</option>
										<option value="28">28</option>
										<option value="29">29</option>
										<option value="30">30</option>
										<option value="31">31</option>
										<option value="32">32</option>
										<option value="33">33</option>
										<option value="34">34</option>
										<option value="35">35</option>
										<option value="36">36</option>
										<option value="37">37</option>
										<option value="38">38</option>
										<option value="39">39</option>
										<option value="40">40</option>
										<option value="41">41</option>
										<option value="42">42</option>
										<option value="43">43</option>
										<option value="44">44</option>
										<option value="45">45</option>
										<option value="46">46</option>
										<option value="47">47</option>
										<option value="48">48</option>
										<option value="49">49</option>
										<option value="50">50</option>
										<option value="51">51</option>
										<option value="52">52</option>
										<option value="53">53</option>
										<option value="54">54</option>
										<option value="55">55</option>
										<option value="56">56</option>
										<option value="57">57</option>
										<option value="58">58</option>
										<option value="59">59</option>
										<option value="60">60</option>
										<option value="61">61</option>
										<option value="62">62</option>
										<option value="63">63</option>
										<option value="64">64</option>
										<option value="65">65</option>
										<option value="66">66</option>
										<option value="67">67</option>
										<option value="68">68</option>
										<option value="69">69</option>
										<option value="70">70</option>
										<option value="71">71</option>
										<option value="72">72</option>
										<option value="73">73</option>
										<option value="74">74</option>
										<option value="75">75</option>
										<option value="76">76</option>
										<option value="77">77</option>
										<option value="78">78</option>
										<option value="79">79</option>
										<option value="80">80</option>
										<option value="81">81</option>
										<option value="82">82</option>
										<option value="83">83</option>
										<option value="84">84</option>
										<option value="85">85</option>
										<option value="86">86</option>
										<option value="87">87</option>
										<option value="88">88</option>
										<option value="89">89</option>
										<option value="90">90</option>
										<option value="91">91</option>
										<option value="92">92</option>
										<option value="93">93</option>
										<option value="94">94</option>
										<option value="95">95</option>
										<option value="96">96</option>
										<option value="97">97</option>
										<option value="98">98</option>
										<option value="99">99</option>
										<option value="100">100</option>
										<option value="101">101</option>
										<option value="102">102</option>
										<option value="103">103</option>
										<option value="104">104</option>
										<option value="105">105</option>
										<option value="106">106</option>
										<option value="107">107</option>
										<option value="108">108</option>
										<option value="109">109</option>
										<option value="110">110</option>
										<option value="111">111</option>
										<option value="112">112</option>
										<option value="113">113</option>
										<option value="114">114</option>
										<option value="115">115</option>
										<option value="116">116</option>
										<option value="117">117</option>
										<option value="118">118</option>
										<option value="119">119</option>
										<option value="120">120</option>
										<option value="121">121</option>
										<option value="122">122</option>
										<option value="123">123</option>
										<option value="124">124</option>
										<option value="125">125</option>
										<option value="126">126</option>
										<option value="127" selected>127</option>
									</select>
								</div>
							</div>
						</div>
						
						<div class="keyboard-settings-grid">
							<!-- Left Column -->
							<div class="keyboard-left-column">
								<!-- Loop Settings -->
								<div class="keyboard-setting-group compact">
									<h3>Loop Settings</h3>
									<div class="keyboard-setting-item aligned">
										<label>Sync Mode:</label>
										<select id="keyboardUnsyncedMode">
											<option value="0">Loop (Note Prime On)</option>
											<option value="4">Loop (Note Prime Off) </option>		
											<option value="2">Unsynced (Note Prime On)</option>
											<option value="5">Unsynced (Note Prime Off)</option>
											<option value="1">BPM - Bar</option>
											<option value="3">BPM - Beat</option>
										</select>
									</div>
									
									<div class="keyboard-setting-item aligned">
										<label>Sample Mode:</label>
										<select id="keyboardSampleMode">
											<option value="false">Off</option>
											<option value="true">On</option>
										</select>
									</div>
									
									<div class="keyboard-setting-item aligned">
										<label>ThruLoop:</label>
										<select id="keyboardLoopMessagingEnabled">
											<option value="false">Off</option>
											<option value="true">On</option>
										</select>
									</div>
									
									<div class="keyboard-setting-item aligned">
										<label>Messaging Channel:</label>
										<select id="keyboardLoopMessagingChannel">
											<option value="1">1</option>
											<option value="2">2</option>
											<option value="3">3</option>
											<option value="4">4</option>
											<option value="5">5</option>
											<option value="6">6</option>
											<option value="7">7</option>
											<option value="8">8</option>
											<option value="9">9</option>
											<option value="10">10</option>
											<option value="11">11</option>
											<option value="12">12</option>
											<option value="13">13</option>
											<option value="14">14</option>
											<option value="15">15</option>
											<option value="16" selected>16</option>
										</select>
									</div>
									
									<div class="keyboard-setting-item aligned">
										<label>ThruLoop Restart Messaging:</label>
										<select id="keyboardSyncMidiMode">
											<option value="false">Off</option>
											<option value="true">On</option>
										</select>
									</div>
									
									<div class="keyboard-setting-item aligned">
										<label>ThruLoop Restart Mode:</label>
										<select id="keyboardAlternateRestartMode">
											<option value="false">Restart CC</option>
											<option value="true">Stop+Start</option>
										</select>
									</div>
																	
								<div class="keyboard-setting-item aligned">
									<label>Overdub Mode:</label>
									<select id="keyboardSmartChordLight">
										<option value="0">Basic Overdub</option>
										<option value="1">8 Track Looper</option>
									</select>
								</div>
								</div>
							</div>

							<!-- Advanced Settings -->
							<div class="keyboard-setting-group">
								<h3>Advanced Settings</h3>
								<div class="keyboard-setting-item aligned">
									<label>Velocity Interval:</label>
									<select id="keyboardVelocitySensitivity">
										<option value="1" selected>1</option>
										<option value="2">2</option>
										<option value="3">3</option>
										<option value="4">4</option>
										<option value="5">5</option>
										<option value="6">6</option>
										<option value="7">7</option>
										<option value="8">8</option>
										<option value="9">9</option>
										<option value="10">10</option>
									</select>
								</div>
								
								<div class="keyboard-setting-item aligned">
									<label>CC Interval:</label>
									<select id="keyboardCcSensitivity">
										<option value="1" selected>1</option>
										<option value="2">2</option>
										<option value="3">3</option>
										<option value="4">4</option>
										<option value="5">5</option>
										<option value="6">6</option>
										<option value="7">7</option>
										<option value="8">8</option>
										<option value="9">9</option>
										<option value="10">10</option>
										<option value="11">11</option>
										<option value="12">12</option>
										<option value="13">13</option>
										<option value="14">14</option>
										<option value="15">15</option>
										<option value="16">16</option>
									</select>
								</div>
								
								<div class="keyboard-setting-item aligned">
									<label>Velocity Shuffle:</label>
									<select id="keyboardRandomVelocityModifier">
										<option value="0" selected>0</option>
										<option value="1">1</option>
										<option value="2">2</option>
										<option value="3">3</option>
										<option value="4">4</option>
										<option value="5">5</option>
										<option value="6">6</option>
										<option value="7">7</option>
										<option value="8">8</option>
										<option value="9">9</option>
										<option value="10">10</option>
										<option value="11">11</option>
										<option value="12">12</option>
										<option value="13">13</option>
										<option value="14">14</option>
										<option value="15">15</option>
										<option value="16">16</option>
									</select>
								</div>
								
								<div class="keyboard-setting-item aligned">
									<label>OLED Keyboard:</label>
									<select id="keyboardOledKeyboard">
										<option value="0">Style 1</option>
										<option value="12">Style 2</option>
									</select>
								</div>
								
								<div class="keyboard-setting-item aligned">
									<label>Guide Lights:</label>
									<select id="keyboardSmartChordLightMode">
										<option value="1">All Off</option>
										<option value="2">Smartchord Off</option>
										<option value="0">All On: Dynamic</option>
										<option value="3">All On: Guitar EADGB</option>
										<option value="4">All On: Guitar ADGBE</option>
									</select>
								</div>
								
								<div class="keyboard-setting-item aligned">
									<label>RGB Layer Mode:</label>
									<select id="keyboardCustomLayerAnimations">
										<option value="false">Off</option>
										<option value="true">On</option>
									</select>
								</div>
								<div class="keyboard-setting-item aligned">
								<label>Colorblind Mode:</label>
								<select id="keyboardColorblindMode">
									<option value="0">Off</option>
									<option value="1">On</option>
								</select>
							</div>

							<div class="keyboard-setting-item aligned">
								<label>CC Loop Recording:</label>
								<select id="keyboardCcLoopRecording">
									<option value="false">Off</option>
									<option value="true">On</option>
								</select>
							</div>

							<div class="keyboard-setting-item aligned">
								<label>True Sustain:</label>
								<select id="keyboardTrueSustain">
									<option value="false">Off</option>
									<option value="true">On</option>
								</select>
							</div>
							</div>
						</div>
							
						<!-- KeySplit Section -->
						<div class="keyboard-keysplit-section">
							<!-- KeySplit Modes -->
							<div class="keyboard-keysplit-modes-box">
								<h3>KeySplit Modes</h3>
								<div class="keyboard-keysplit-modes-row">
									<div class="keyboard-setting-item">
										<label>Channel:</label>
										<select id="keyboardKeySplitStatus">
											<option value="0">Disable Keysplit</option>
											<option value="1">KeySplit On</option>
											<option value="2">TripleSplit On</option>
										</select>
									</div>
									
									<div class="keyboard-setting-item">
										<label>Transpose:</label>
										<select id="keyboardKeySplitTransposeStatus">
											<option value="0">Disable Keysplit</option>
											<option value="1">KeySplit On</option>
											<option value="2">TripleSplit On</option>
										</select>
									</div>
									
									<div class="keyboard-setting-item">
										<label>Velocity:</label>
										<select id="keyboardKeySplitVelocityStatus">
											<option value="0">Disable Keysplit</option>
											<option value="1">KeySplit On</option>
											<option value="2">TripleSplit On</option>
										</select>
									</div>
								</div>
							</div>
							
							<!-- KeySplit and TripleSplit Settings Side by Side -->
							<div class="keyboard-keysplit-settings">
								<!-- KeySplit Settings -->
								<div class="keyboard-setting-group">
									<h3>KeySplit Settings</h3>
									<div class="keyboard-setting-item aligned">
										<label>Channel:</label>
										<select id="keyboardKeySplitChannel">
											<option value="0">1</option>
											<option value="1">2</option>
											<option value="2">3</option>
											<option value="3">4</option>
											<option value="4">5</option>
											<option value="5">6</option>
											<option value="6">7</option>
											<option value="7">8</option>
											<option value="8">9</option>
											<option value="9">10</option>
											<option value="10">11</option>
											<option value="11">12</option>
											<option value="12">13</option>
											<option value="13">14</option>
											<option value="14">15</option>
											<option value="15">16</option>
										</select>
									</div>
									
									<div class="keyboard-setting-item aligned">
										<label>Transpose:</label>
										<select id="keyboardTransposeNumber2">
											<option value="-64">-64</option>
											<option value="-63">-63</option>
											<option value="-62">-62</option>
											<option value="-61">-61</option>
											<option value="-60">-60</option>
											<option value="-59">-59</option>
											<option value="-58">-58</option>
											<option value="-57">-57</option>
											<option value="-56">-56</option>
											<option value="-55">-55</option>
											<option value="-54">-54</option>
											<option value="-53">-53</option>
											<option value="-52">-52</option>
											<option value="-51">-51</option>
											<option value="-50">-50</option>
											<option value="-49">-49</option>
											<option value="-48">-48</option>
											<option value="-47">-47</option>
											<option value="-46">-46</option>
											<option value="-45">-45</option>
											<option value="-44">-44</option>
											<option value="-43">-43</option>
											<option value="-42">-42</option>
											<option value="-41">-41</option>
											<option value="-40">-40</option>
											<option value="-39">-39</option>
											<option value="-38">-38</option>
											<option value="-37">-37</option>
											<option value="-36">-36</option>
											<option value="-35">-35</option>
											<option value="-34">-34</option>
											<option value="-33">-33</option>
											<option value="-32">-32</option>
											<option value="-31">-31</option>
											<option value="-30">-30</option>
											<option value="-29">-29</option>
											<option value="-28">-28</option>
											<option value="-27">-27</option>
											<option value="-26">-26</option>
											<option value="-25">-25</option>
											<option value="-24">-24</option>
											<option value="-23">-23</option>
											<option value="-22">-22</option>
											<option value="-21">-21</option>
											<option value="-20">-20</option>
											<option value="-19">-19</option>
											<option value="-18">-18</option>
											<option value="-17">-17</option>
											<option value="-16">-16</option>
											<option value="-15">-15</option>
											<option value="-14">-14</option>
											<option value="-13">-13</option>
											<option value="-12">-12</option>
											<option value="-11">-11</option>
											<option value="-10">-10</option>
											<option value="-9">-9</option>
											<option value="-8">-8</option>
											<option value="-7">-7</option>
											<option value="-6">-6</option>
											<option value="-5">-5</option>
											<option value="-4">-4</option>
											<option value="-3">-3</option>
											<option value="-2">-2</option>
											<option value="-1">-1</option>
											<option value="0" selected>0</option>
											<option value="1">+1</option>
											<option value="2">+2</option>
											<option value="3">+3</option>
											<option value="4">+4</option>
											<option value="5">+5</option>
											<option value="6">+6</option>
											<option value="7">+7</option>
											<option value="8">+8</option>
											<option value="9">+9</option>
											<option value="10">+10</option>
											<option value="11">+11</option>
											<option value="12">+12</option>
											<option value="13">+13</option>
											<option value="14">+14</option>
											<option value="15">+15</option>
											<option value="16">+16</option>
											<option value="17">+17</option>
											<option value="18">+18</option>
											<option value="19">+19</option>
											<option value="20">+20</option>
											<option value="21">+21</option>
											<option value="22">+22</option>
											<option value="23">+23</option>
											<option value="24">+24</option>
											<option value="25">+25</option>
											<option value="26">+26</option>
											<option value="27">+27</option>
											<option value="28">+28</option>
											<option value="29">+29</option>
											<option value="30">+30</option>
											<option value="31">+31</option>
											<option value="32">+32</option>
											<option value="33">+33</option>
											<option value="34">+34</option>
											<option value="35">+35</option>
											<option value="36">+36</option>
											<option value="37">+37</option>
											<option value="38">+38</option>
											<option value="39">+39</option>
											<option value="40">+40</option>
											<option value="41">+41</option>
											<option value="42">+42</option>
											<option value="43">+43</option>
											<option value="44">+44</option>
											<option value="45">+45</option>
											<option value="46">+46</option>
											<option value="47">+47</option>
											<option value="48">+48</option>
											<option value="49">+49</option>
											<option value="50">+50</option>
											<option value="51">+51</option>
											<option value="52">+52</option>
											<option value="53">+53</option>
											<option value="54">+54</option>
											<option value="55">+55</option>
											<option value="56">+56</option>
											<option value="57">+57</option>
											<option value="58">+58</option>
											<option value="59">+59</option>
											<option value="60">+60</option>
											<option value="61">+61</option>
											<option value="62">+62</option>
											<option value="63">+63</option>
											<option value="64">+64</option>
										</select>
									</div>
									
									<div class="keyboard-setting-item aligned">
										<label>Velocity:</label>
										<select id="keyboardVelocityNumber2">
											<option value="1">1</option>
											<option value="2">2</option>
											<option value="3">3</option>
											<option value="4">4</option>
											<option value="5">5</option>
											<option value="6">6</option>
											<option value="7">7</option>
											<option value="8">8</option>
											<option value="9">9</option>
											<option value="10">10</option>
											<option value="11">11</option>
											<option value="12">12</option>
											<option value="13">13</option>
											<option value="14">14</option>
											<option value="15">15</option>
											<option value="16">16</option>
											<option value="17">17</option>
											<option value="18">18</option>
											<option value="19">19</option>
											<option value="20">20</option>
											<option value="21">21</option>
											<option value="22">22</option>
											<option value="23">23</option>
											<option value="24">24</option>
											<option value="25">25</option>
											<option value="26">26</option>
											<option value="27">27</option>
											<option value="28">28</option>
											<option value="29">29</option>
											<option value="30">30</option>
											<option value="31">31</option>
											<option value="32">32</option>
											<option value="33">33</option>
											<option value="34">34</option>
											<option value="35">35</option>
											<option value="36">36</option>
											<option value="37">37</option>
											<option value="38">38</option>
											<option value="39">39</option>
											<option value="40">40</option>
											<option value="41">41</option>
											<option value="42">42</option>
											<option value="43">43</option>
											<option value="44">44</option>
											<option value="45">45</option>
											<option value="46">46</option>
											<option value="47">47</option>
											<option value="48">48</option>
											<option value="49">49</option>
											<option value="50">50</option>
											<option value="51">51</option>
											<option value="52">52</option>
											<option value="53">53</option>
											<option value="54">54</option>
											<option value="55">55</option>
											<option value="56">56</option>
											<option value="57">57</option>
											<option value="58">58</option>
											<option value="59">59</option>
											<option value="60">60</option>
											<option value="61">61</option>
											<option value="62">62</option>
											<option value="63">63</option>
											<option value="64">64</option>
											<option value="65">65</option>
											<option value="66">66</option>
											<option value="67">67</option>
											<option value="68">68</option>
											<option value="69">69</option>
											<option value="70">70</option>
											<option value="71">71</option>
											<option value="72">72</option>
											<option value="73">73</option>
											<option value="74">74</option>
											<option value="75">75</option>
											<option value="76">76</option>
											<option value="77">77</option>
											<option value="78">78</option>
											<option value="79">79</option>
											<option value="80">80</option>
											<option value="81">81</option>
											<option value="82">82</option>
											<option value="83">83</option>
											<option value="84">84</option>
											<option value="85">85</option>
											<option value="86">86</option>
											<option value="87">87</option>
											<option value="88">88</option>
											<option value="89">89</option>
											<option value="90">90</option>
											<option value="91">91</option>
											<option value="92">92</option>
											<option value="93">93</option>
											<option value="94">94</option>
											<option value="95">95</option>
											<option value="96">96</option>
											<option value="97">97</option>
											<option value="98">98</option>
											<option value="99">99</option>
											<option value="100">100</option>
											<option value="101">101</option>
											<option value="102">102</option>
											<option value="103">103</option>
											<option value="104">104</option>
											<option value="105">105</option>
											<option value="106">106</option>
											<option value="107">107</option>
											<option value="108">108</option>
											<option value="109">109</option>
											<option value="110">110</option>
											<option value="111">111</option>
											<option value="112">112</option>
											<option value="113">113</option>
											<option value="114">114</option>
											<option value="115">115</option>
											<option value="116">116</option>
											<option value="117">117</option>
											<option value="118">118</option>
											<option value="119">119</option>
											<option value="120">120</option>
											<option value="121">121</option>
											<option value="122">122</option>
											<option value="123">123</option>
											<option value="124">124</option>
											<option value="125">125</option>
											<option value="126">126</option>
											<option value="127" selected>127</option>
										</select>
									</div>
								</div>

								<!-- TripleSplit Settings -->
								<div class="keyboard-setting-group">
									<h3>TripleSplit Settings</h3>
									<div class="keyboard-setting-item aligned">
										<label>Channel:</label>
										<select id="keyboardKeySplit2Channel">
											<option value="0">1</option>
											<option value="1">2</option>
											<option value="2">3</option>
											<option value="3">4</option>
											<option value="4">5</option>
											<option value="5">6</option>
											<option value="6">7</option>
											<option value="7">8</option>
											<option value="8">9</option>
											<option value="9">10</option>
											<option value="10">11</option>
											<option value="11">12</option>
											<option value="12">13</option>
											<option value="13">14</option>
											<option value="14">15</option>
											<option value="15">16</option>
										</select>
									</div>
									
									<div class="keyboard-setting-item aligned">
										<label>Transpose:</label>
										<select id="keyboardTransposeNumber3">
											<option value="-64">-64</option>
											<option value="-63">-63</option>
											<option value="-62">-62</option>
											<option value="-61">-61</option>
											<option value="-60">-60</option>
											<option value="-59">-59</option>
											<option value="-58">-58</option>
											<option value="-57">-57</option>
											<option value="-56">-56</option>
											<option value="-55">-55</option>
											<option value="-54">-54</option>
											<option value="-53">-53</option>
											<option value="-52">-52</option>
											<option value="-51">-51</option>
											<option value="-50">-50</option>
											<option value="-49">-49</option>
											<option value="-48">-48</option>
											<option value="-47">-47</option>
											<option value="-46">-46</option>
											<option value="-45">-45</option>
											<option value="-44">-44</option>
											<option value="-43">-43</option>
											<option value="-42">-42</option>
											<option value="-41">-41</option>
											<option value="-40">-40</option>
											<option value="-39">-39</option>
											<option value="-38">-38</option>
											<option value="-37">-37</option>
											<option value="-36">-36</option>
											<option value="-35">-35</option>
											<option value="-34">-34</option>
											<option value="-33">-33</option>
											<option value="-32">-32</option>
											<option value="-31">-31</option>
											<option value="-30">-30</option>
											<option value="-29">-29</option>
											<option value="-28">-28</option>
											<option value="-27">-27</option>
											<option value="-26">-26</option>
											<option value="-25">-25</option>
											<option value="-24">-24</option>
											<option value="-23">-23</option>
											<option value="-22">-22</option>
											<option value="-21">-21</option>
											<option value="-20">-20</option>
											<option value="-19">-19</option>
											<option value="-18">-18</option>
											<option value="-17">-17</option>
											<option value="-16">-16</option>
											<option value="-15">-15</option>
											<option value="-14">-14</option>
											<option value="-13">-13</option>
											<option value="-12">-12</option>
											<option value="-11">-11</option>
											<option value="-10">-10</option>
											<option value="-9">-9</option>
											<option value="-8">-8</option>
											<option value="-7">-7</option>
											<option value="-6">-6</option>
											<option value="-5">-5</option>
											<option value="-4">-4</option>
											<option value="-3">-3</option>
											<option value="-2">-2</option>
											<option value="-1">-1</option>
											<option value="0" selected>0</option>
											<option value="1">+1</option>
											<option value="2">+2</option>
											<option value="3">+3</option>
											<option value="4">+4</option>
											<option value="5">+5</option>
											<option value="6">+6</option>
											<option value="7">+7</option>
											<option value="8">+8</option>
											<option value="9">+9</option>
											<option value="10">+10</option>
											<option value="11">+11</option>
											<option value="12">+12</option>
											<option value="13">+13</option>
											<option value="14">+14</option>
											<option value="15">+15</option>
											<option value="16">+16</option>
											<option value="17">+17</option>
											<option value="18">+18</option>
											<option value="19">+19</option>
											<option value="20">+20</option>
											<option value="21">+21</option>
											<option value="22">+22</option>
											<option value="23">+23</option>
											<option value="24">+24</option>
											<option value="25">+25</option>
											<option value="26">+26</option>
											<option value="27">+27</option>
											<option value="28">+28</option>
											<option value="29">+29</option>
											<option value="30">+30</option>
											<option value="31">+31</option>
											<option value="32">+32</option>
											<option value="33">+33</option>
											<option value="34">+34</option>
											<option value="35">+35</option>
											<option value="36">+36</option>
											<option value="37">+37</option>
											<option value="38">+38</option>
											<option value="39">+39</option>
											<option value="40">+40</option>
											<option value="41">+41</option>
											<option value="42">+42</option>
											<option value="43">+43</option>
											<option value="44">+44</option>
											<option value="45">+45</option>
											<option value="46">+46</option>
											<option value="47">+47</option>
											<option value="48">+48</option>
											<option value="49">+49</option>
											<option value="50">+50</option>
											<option value="51">+51</option>
											<option value="52">+52</option>
											<option value="53">+53</option>
											<option value="54">+54</option>
											<option value="55">+55</option>
											<option value="56">+56</option>
											<option value="57">+57</option>
											<option value="58">+58</option>
											<option value="59">+59</option>
											<option value="60">+60</option>
											<option value="61">+61</option>
											<option value="62">+62</option>
											<option value="63">+63</option>
											<option value="64">+64</option>
										</select>
									</div>
									
									<div class="keyboard-setting-item aligned">
										<label>Velocity:</label>
										<select id="keyboardVelocityNumber3">
											<option value="1">1</option>
											<option value="2">2</option>
											<option value="3">3</option>
											<option value="4">4</option>
											<option value="5">5</option>
											<option value="6">6</option>
											<option value="7">7</option>
											<option value="8">8</option>
											<option value="9">9</option>
											<option value="10">10</option>
											<option value="11">11</option>
											<option value="12">12</option>
											<option value="13">13</option>
											<option value="14">14</option>
											<option value="15">15</option>
											<option value="16">16</option>
											<option value="17">17</option>
											<option value="18">18</option>
											<option value="19">19</option>
											<option value="20">20</option>
											<option value="21">21</option>
											<option value="22">22</option>
											<option value="23">23</option>
											<option value="24">24</option>
											<option value="25">25</option>
											<option value="26">26</option>
											<option value="27">27</option>
											<option value="28">28</option>
											<option value="29">29</option>
											<option value="30">30</option>
											<option value="31">31</option>
											<option value="32">32</option>
											<option value="33">33</option>
											<option value="34">34</option>
											<option value="35">35</option>
											<option value="36">36</option>
											<option value="37">37</option>
											<option value="38">38</option>
											<option value="39">39</option>
											<option value="40">40</option>
											<option value="41">41</option>
											<option value="42">42</option>
											<option value="43">43</option>
											<option value="44">44</option>
											<option value="45">45</option>
											<option value="46">46</option>
											<option value="47">47</option>
											<option value="48">48</option>
											<option value="49">49</option>
											<option value="50">50</option>
											<option value="51">51</option>
											<option value="52">52</option>
											<option value="53">53</option>
											<option value="54">54</option>
											<option value="55">55</option>
											<option value="56">56</option>
											<option value="57">57</option>
											<option value="58">58</option>
											<option value="59">59</option>
											<option value="60">60</option>
											<option value="61">61</option>
											<option value="62">62</option>
											<option value="63">63</option>
											<option value="64">64</option>
											<option value="65">65</option>
											<option value="66">66</option>
											<option value="67">67</option>
											<option value="68">68</option>
											<option value="69">69</option>
											<option value="70">70</option>
											<option value="71">71</option>
											<option value="72">72</option>
											<option value="73">73</option>
											<option value="74">74</option>
											<option value="75">75</option>
											<option value="76">76</option>
											<option value="77">77</option>
											<option value="78">78</option>
											<option value="79">79</option>
											<option value="80">80</option>
											<option value="81">81</option>
											<option value="82">82</option>
											<option value="83">83</option>
											<option value="84">84</option>
											<option value="85">85</option>
											<option value="86">86</option>
											<option value="87">87</option>
											<option value="88">88</option>
											<option value="89">89</option>
											<option value="90">90</option>
											<option value="91">91</option>
											<option value="92">92</option>
											<option value="93">93</option>
											<option value="94">94</option>
											<option value="95">95</option>
											<option value="96">96</option>
											<option value="97">97</option>
											<option value="98">98</option>
											<option value="99">99</option>
											<option value="100">100</option>
											<option value="101">101</option>
											<option value="102">102</option>
											<option value="103">103</option>
											<option value="104">104</option>
											<option value="105">105</option>
											<option value="106">106</option>
											<option value="107">107</option>
											<option value="108">108</option>
											<option value="109">109</option>
											<option value="110">110</option>
											<option value="111">111</option>
											<option value="112">112</option>
											<option value="113">113</option>
											<option value="114">114</option>
											<option value="115">115</option>
											<option value="116">116</option>
											<option value="117">117</option>
											<option value="118">118</option>
											<option value="119">119</option>
											<option value="120">120</option>
											<option value="121">121</option>
											<option value="122">122</option>
											<option value="123">123</option>
											<option value="124">124</option>
											<option value="125">125</option>
											<option value="126">126</option>
											<option value="127" selected>127</option>
										</select>
									</div>
								</div>
							</div>
						</div>
					</div>

					<div class="keyboard-container keyboard-button-group">
						<!-- Default and File Buttons Row -->
						<div class="keyboard-button-row keyboard-default-buttons">
							<button id="keyboardSaveSlot0Btn" class="keyboard-default-btn">Save as Default</button>
							<button id="keyboardLoadSlot0Btn" class="keyboard-default-btn">Load Default</button>
							<button id="keyboardResetBtn" class="keyboard-reset-btn">Reset to Defaults</button>
							<button id="keyboardSaveFileBtn" class="keyboard-file-btn">Save to File</button>
							<button id="keyboardLoadFileBtn" class="keyboard-file-btn">Load from File</button>
						</div>
						
						<!-- Save Slot Buttons Row -->
						<div class="keyboard-button-row keyboard-slot-save-buttons">
							<button id="keyboardSaveSlot1Btn" class="keyboard-save-preset-btn">Save to Slot 1</button>
							<button id="keyboardSaveSlot2Btn" class="keyboard-save-preset-btn">Save to Slot 2</button>
							<button id="keyboardSaveSlot3Btn" class="keyboard-save-preset-btn">Save to Slot 3</button>
							<button id="keyboardSaveSlot4Btn" class="keyboard-save-preset-btn">Save to Slot 4</button>
						</div>
						
						<!-- Load Slot Buttons Row -->
						<div class="keyboard-button-row keyboard-slot-load-buttons">
							<button id="keyboardLoadSlot1Btn" class="keyboard-load-preset-btn">Load Slot 1</button>
							<button id="keyboardLoadSlot2Btn" class="keyboard-load-preset-btn">Load Slot 2</button>
							<button id="keyboardLoadSlot3Btn" class="keyboard-load-preset-btn">Load Slot 3</button>
							<button id="keyboardLoadSlot4Btn" class="keyboard-load-preset-btn">Load Slot 4</button>
						</div>
						
						<input type="file" id="keyboardFileInput" accept=".json" style="display: none;">
						<div id="keyboardSendStatus" class="keyboard-status"></div>
					</div>
				</div>
			</div>
		</div>
        <!-- Floating Progress Bar -->
        <div class="floating-progress" id="floatingProgress">
            <h3 id="floatingProgressTitle">Processing MIDI File...</h3>
            <div class="floating-progress-bar">
                <div class="floating-progress-fill" id="floatingProgressFill"></div>
            </div>
            <div class="floating-progress-text" id="floatingProgressText">
                <span class="floating-progress-spinner"></span>
                Initializing...
            </div>
        </div>
        
        <!-- Debug Log -->
        <div class="debug" id="debugLog">
            Debug log will appear here...
        </div>
    </div>

    <script>
        // HID Protocol Constants
        const HID_MANUFACTURER_ID = 0x7D;
        const HID_DEVICE_ID = 0x4D;
        const HID_SUB_ID = 0x00;

        // Save/Load Operations (0xA0-0xA7)
        const HID_CMD_SAVE_START = 0xA0;              // was 0x01
        const HID_CMD_SAVE_CHUNK = 0xA1;              // was 0x02
        const HID_CMD_SAVE_END = 0xA2;                // was 0x03
        const HID_CMD_LOAD_START = 0xA3;              // was 0x04
        const HID_CMD_LOAD_CHUNK = 0xA4;              // was 0x05
        const HID_CMD_LOAD_END = 0xA5;                // was 0x06
        const HID_CMD_LOAD_OVERDUB_START = 0xA6;      // was 0x07
        
        // Request/Trigger Operations (0xA8-0xAF)
        const HID_CMD_REQUEST_SAVE = 0xA8;            // was 0x10
        const HID_CMD_TRIGGER_SAVE_ALL = 0xA9;        // was 0x30

        const HID_PACKET_SIZE = 32;
        const HID_HEADER_SIZE = 6;
        const HID_DATA_SIZE = HID_PACKET_SIZE - HID_HEADER_SIZE;
        const HID_CHUNK_SIZE = HID_DATA_SIZE - 4; // Reserve 4 bytes for chunk info

        // MIDI Constants
        const MIDI_TPQN = 480; // Ticks per quarter note
        const MIDI_EVENT_NOTE_ON = 1;
        const MIDI_EVENT_NOTE_OFF = 0;
        const MIDI_EVENT_CC = 2;

        // Global variables
        let hidDevice = null;
        let isConnected = false;
        let defaultSaveFolder = null;
        
        // MIDI Patchbay Variables
        let midiAccess = null;
        let midiConnections = [];
        let initAttempts = 0;
        const maxInitAttempts = 5;
        let midiswitchOutput = null;
        
        let currentTransfer = {
            active: false,
            isLoading: false,
            loopNum: 0,
            expectedPackets: 0,
            receivedPackets: 0,
            totalSize: 0,
            receivedData: [],
            fileName: ''
        };
        
        let selectedFile = null;
        let loadedFiles = [];
        let pendingSaveAll = false;
        let saveAllLoopsData = {};
        let saveAllName = '';
        let saveAllTargetPath = '';
        let availableTracksInFile = [];
        let currentLoopContents = {}; // Track what's currently in each loop
        let currentOverdubContents = {}; // Track what's currently in each overdub
        let selectedTrack = null; // Currently selected track for assignment
        let pendingAssignments = {}; // Track assignments that haven't been loaded yet

        // Debug logging - now only to console, debug box is hidden
        function debugLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const fullMessage = `[${timestamp}] ${message}`;
            
            // Always log to console
            console.log(fullMessage);
            
            // Still update the debug div (even though it's hidden) in case someone wants to show it
            const debugDiv = document.getElementById('debugLog');
            if (debugDiv) {
                debugDiv.innerHTML += `${fullMessage}<br>`;
                debugDiv.scrollTop = debugDiv.scrollHeight;
            }
        }

        // Status display
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="${type}">${message}</div>`;
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 5000);
        }

        // Toggle advanced options visibility
        function toggleAdvancedOptions() {
            const checkbox = document.getElementById('showAdvanced');
            const advancedSection = document.getElementById('advancedTrackSection');
            
            // Toggle the checkbox state when button is clicked
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                advancedSection.classList.add('visible');
                updateTrackSelection(); // Populate tracks when enabled
                updateAssignmentButtonLabels(); // Initialize button labels
                updateLoadAssignmentsButtonState(); // Initialize load button state
            } else {
                advancedSection.classList.remove('visible');
                clearTrackSelection();
            }
        }

        // Update UI connection status
        function updateConnectionStatus() {
            const statusLight = document.getElementById('hidStatusLight');
            const statusText = document.getElementById('statusText');
            const connectBtn = document.getElementById('connectBtn');
            const connectionBar = document.querySelector('.connection-bar');
            const loopManager = document.getElementById('loopManager');
            
            if (isConnected && hidDevice) {
                statusLight.className = 'status-light connected';
                statusText.textContent = 'MIDIswitch Connected';
                connectionBar.style.display = 'none';
                loopManager.style.display = 'block';
                debugLog('âœ… HID connection established');
            } else {
                statusLight.className = 'status-light disconnected';
                statusText.textContent = 'MIDIswitch Disconnected';
                connectBtn.textContent = 'Connect Device';
                connectBtn.disabled = false;
                connectionBar.style.display = 'flex';
                loopManager.style.display = 'none';
                debugLog('âŒ HID connection lost');
            }
        }

        // OPTIMIZED: Quick BPM extraction from last 5 bytes only
        function extractBPMQuickly(data) {
            debugLog(`âš¡ QUICK BPM: extracting from last 5 bytes of ${data.length} total bytes`);
            
            if (data.length < 5) {
                debugLog(`âš¡ QUICK BPM: file too short, using default 120 BPM`);
                return 120; // Default BPM
            }
            
            const lastFiveBytes = data.slice(-5);
            debugLog(`âš¡ QUICK BPM: last 5 bytes: [${Array.from(lastFiveBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')}]`);
            
            const bpmFlag = lastFiveBytes[0];
            debugLog(`âš¡ QUICK BPM: flag byte: 0x${bpmFlag.toString(16)} (${bpmFlag})`);
            
            if (bpmFlag !== 0x01) {
                debugLog(`âš¡ QUICK BPM: flag indicates no BPM set, using default 120 BPM`);
                return 120; // Default BPM if this loop didn't set BPM
            }
            
            // Extract 3-byte BPM value (bytes 2, 3, 4 of the last 5 bytes)
            const bpmBytes = lastFiveBytes.slice(2, 5);
            debugLog(`âš¡ QUICK BPM: bmp bytes: [${Array.from(bpmBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')}]`);
            
            const bpmValue = (bpmBytes[0] << 16) | (bpmBytes[1] << 8) | bpmBytes[2];
            debugLog(`âš¡ QUICK BPM: raw bmp value: ${bpmValue}`);
            
            const bpm = bpmValue / 100000;
            debugLog(`âš¡ QUICK BPM: calculated BPM: ${bpm}`);
            
            const finalBPM = Math.round(bpm * 10) / 10; // Round to 1 decimal place
            debugLog(`âš¡ QUICK BPM: final BPM: ${finalBPM}`);
            
            return finalBPM;
        }

        // Extract BPM from loop data (using the pattern we discovered)
        function extractBPMFromLoopData(data) {
            debugLog(`ðŸ” DEBUG BPM: extracting from ${data.length} bytes`);
            
            if (data.length < 5) {
                debugLog(`ðŸ” DEBUG BPM: file too short, using default 120 BPM`);
                return 120; // Default BPM
            }
            
            const lastFiveBytes = data.slice(-5);
            debugLog(`ðŸ” DEBUG BPM: last 5 bytes: [${Array.from(lastFiveBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')}]`);
            
            const bpmFlag = lastFiveBytes[0];
            debugLog(`ðŸ” DEBUG BPM: flag byte: 0x${bpmFlag.toString(16)} (${bpmFlag})`);
            
            if (bpmFlag !== 0x01) {
                debugLog(`ðŸ” DEBUG BPM: flag indicates no BPM set, using default 120 BPM`);
                return 120; // Default BPM if this loop didn't set BPM
            }
            
            // Extract 3-byte BPM value (bytes 2, 3, 4 of the last 5 bytes)
            const bpmBytes = lastFiveBytes.slice(2, 5);
            debugLog(`ðŸ” DEBUG BPM: bmp bytes: [${Array.from(bpmBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')}]`);
            
            const bpmValue = (bpmBytes[0] << 16) | (bpmBytes[1] << 8) | bpmBytes[2];
            debugLog(`ðŸ” DEBUG BPM: raw bmp value: ${bpmValue}`);
            
            const bpm = bpmValue / 100000;
            debugLog(`ðŸ” DEBUG BPM: calculated BPM: ${bpm}`);
            
            const finalBPM = Math.round(bpm * 10) / 10; // Round to 1 decimal place
            debugLog(`ðŸ” DEBUG BPM: final BPM: ${finalBPM}`);
            
            return finalBPM;
        }

        // Convert milliseconds to MIDI ticks
        function msToTicks(ms, bpm) {
            // Formula: ticks = ms / (60000 / (BPM * TPQN))
            const msPerTick = 60000 / (bpm * MIDI_TPQN);
            const ticks = Math.round(ms / msPerTick);
            
            debugLog(`ðŸ” DEBUG TICK: converting ${ms}ms to ticks at ${bpm} BPM`);
            debugLog(`ðŸ” DEBUG TICK: ms per tick = 60000 / (${bpm} * ${MIDI_TPQN}) = ${msPerTick}`);
            debugLog(`ðŸ” DEBUG TICK: ${ms}ms = ${ticks} ticks`);
            
            return ticks;
        }

        // Convert MIDI ticks to milliseconds  
        function ticksToMs(ticks, bpm) {
            // Formula: ms = ticks * (60000 / (BPM * TPQN))
            const msPerTick = 60000 / (bpm * MIDI_TPQN);
            return Math.round(ticks * msPerTick);
        }

        // Replace the parseLoopData function with this enhanced version
        function parseLoopData(data) {
            debugLog(`ðŸ“‹ DEBUG PARSE: parsing loop data: ${data.length} bytes`);
            debugLog(`ðŸ“‹ DEBUG PARSE: first 20 bytes: [${Array.from(data.slice(0, 20)).map(b => b.toString(16).padStart(2, '0')).join(' ')}]`);
            
            // Check header
            if (data.length < 4 || data[0] !== 0xAA || data[1] !== 0x55) {
                debugLog('âŒ Invalid loop file header');
                return null;
            }
            
            const version = data[2];
            const loopNum = data[3];
            let offset = 4;
            
            debugLog(`ðŸ“‹ DEBUG PARSE: Loop ${loopNum}, version ${version}`);
            
            // Read main macro size
            if (offset + 2 > data.length) {
                debugLog(`âŒ DEBUG PARSE: insufficient data for main size`);
                return null;
            }
            const mainSize = (data[offset] << 8) | data[offset + 1];
            offset += 2;
            
            debugLog(`ðŸ“‹ DEBUG PARSE: Main macro size: ${mainSize} bytes at offset ${offset - 2}`);
            
            // Parse main macro events
            const mainEvents = [];
            if (mainSize > 0) {
                if (offset + mainSize > data.length) {
                    debugLog(`âŒ DEBUG PARSE: insufficient data for main events`);
                    return null;
                }
                debugLog(`ðŸ“‹ DEBUG PARSE: parsing ${mainSize} bytes of main data`);
                const mainData = data.slice(offset, offset + mainSize);
                
                // Add raw data debugging
                debugRawEventData(mainData, 3);
                
                const events = parseMIDIEvents(mainData);
                mainEvents.push(...events);
                offset += mainSize;
            }
            
            debugLog(`ðŸ“‹ DEBUG PARSE: found ${mainEvents.length} main events`);
            
            // Count note types in main events
            const mainNoteOns = mainEvents.filter(e => e.type === 1).length;
            const mainNoteOffs = mainEvents.filter(e => e.type === 2).length;
            const mainCCs = mainEvents.filter(e => e.type === 3).length;
            debugLog(`ðŸ“‹ DEBUG PARSE: main events breakdown: ${mainNoteOns} note-ons, ${mainNoteOffs} note-offs, ${mainCCs} CCs`);
            
            // Read overdub size
            if (offset + 2 > data.length) {
                debugLog(`âŒ DEBUG PARSE: insufficient data for overdub size`);
                return null;
            }
            const overdubSize = (data[offset] << 8) | data[offset + 1];
            offset += 2;
            
            debugLog(`ðŸ“‹ DEBUG PARSE: Overdub size: ${overdubSize} bytes at offset ${offset - 2}`);
            
            // Parse overdub events
            const overdubEvents = [];
            if (overdubSize > 0) {
                if (offset + overdubSize > data.length) {
                    debugLog(`âŒ DEBUG PARSE: insufficient data for overdub events`);
                    return null;
                }
                debugLog(`ðŸ“‹ DEBUG PARSE: parsing ${overdubSize} bytes of overdub data`);
                const overdubData = data.slice(offset, offset + overdubSize);
                
                // Add raw data debugging for overdub too
                debugRawEventData(overdubData, 3);
                
                const events = parseMIDIEvents(overdubData);
                overdubEvents.push(...events);
                offset += overdubSize;
            }
            
            debugLog(`ðŸ“‹ DEBUG PARSE: found ${overdubEvents.length} overdub events`);
            
            // Count note types in overdub events
            const overdubNoteOns = overdubEvents.filter(e => e.type === 1).length;
            const overdubNoteOffs = overdubEvents.filter(e => e.type === 2).length;
            const overdubCCs = overdubEvents.filter(e => e.type === 3).length;
            debugLog(`ðŸ“‹ DEBUG PARSE: overdub events breakdown: ${overdubNoteOns} note-ons, ${overdubNoteOffs} note-offs, ${overdubCCs} CCs`);
            
            if (offset + 7 <= data.length) {
                offset += 7; // Skip transformation data
                debugLog(`ðŸ“‹ DEBUG PARSE: skipped 7 bytes of transformation settings`);
            }

            // Extract timing info (8 bytes: 4 for loop_length, 4 for loop_gap)
            let loopLength = 0;
            let loopGap = 0;
            if (offset + 8 <= data.length) {
                loopLength = (data[offset] << 24) | (data[offset+1] << 16) | 
                             (data[offset+2] << 8) | data[offset+3];
                offset += 4;
                
                loopGap = (data[offset] << 24) | (data[offset+1] << 16) | 
                          (data[offset+2] << 8) | data[offset+3];
                offset += 4;
                
                debugLog(`ðŸ“‹ DEBUG PARSE: Loop timing - length: ${loopLength}ms, gap: ${loopGap}ms`);
            } else {
                debugLog(`âš ï¸ DEBUG PARSE: insufficient data for timing info`);
            }
            
            // Extract BPM from the loop data
            const bpm = extractBPMFromLoopData(data);
            
            debugLog(`ðŸ“‹ DEBUG PARSE: Final result - ${mainEvents.length} main events, ${overdubEvents.length} overdub events, ${bpm} BPM`);
            
            // Log some sample events for verification
            if (mainEvents.length > 0) {
                debugLog(`ðŸ“‹ DEBUG PARSE: First main event: type=${mainEvents[0].type}, ch=${mainEvents[0].channel}, note=${mainEvents[0].note}, vel=${mainEvents[0].velocity}, time=${mainEvents[0].timestamp}ms`);
                if (mainEvents.length > 1) {
                    debugLog(`ðŸ“‹ DEBUG PARSE: Second main event: type=${mainEvents[1].type}, ch=${mainEvents[1].channel}, note=${mainEvents[1].note}, vel=${mainEvents[1].velocity}, time=${mainEvents[1].timestamp}ms`);
                }
                
                // Look for note-off events specifically
                const firstNoteOff = mainEvents.find(e => e.type === 2);
                if (firstNoteOff) {
                    debugLog(`ðŸ“‹ DEBUG PARSE: First note-off found: ch=${firstNoteOff.channel}, note=${firstNoteOff.note}, vel=${firstNoteOff.velocity}, time=${firstNoteOff.timestamp}ms`);
                } else {
                    debugLog(`âš ï¸ DEBUG PARSE: NO NOTE-OFFS FOUND in main events!`);
                }
            }
            
            return {
                loopNum,
                mainEvents,
                overdubEvents,
                bpm,
                loopLength: loopLength,  // ADD THIS
                loopGap: loopGap        // ADD THIS
            };
        }

// Replace the parseMIDIEvents function with this corrected version
function parseMIDIEvents(data) {
    debugLog(`ðŸ” DEBUG EVENTS: parsing ${data.length} bytes of event data`);
    
    // First, let's determine the actual event size by examining the data structure
    // The C struct is: type(1) + channel(1) + note(1) + velocity(1) + timestamp(4) = 8 bytes minimum
    // But it might be padded to 12 or 16 bytes for alignment
    
    const events = [];
    
    // Try each possible event size and see which gives us the most coherent data
    const candidateSizes = [8, 12, 16];
    let bestResult = null;
    let bestScore = -1;
    
    for (const eventSize of candidateSizes) {
        const candidateEvents = [];
        let validEvents = 0;
        let invalidEvents = 0;
        let lastTimestamp = 0;
        let timestampIncreases = 0;
        let timestampDecreases = 0;
        
        debugLog(`ðŸ” DEBUG EVENTS: trying eventSize=${eventSize}`);
        
        let offset = 0;
        while (offset + eventSize <= data.length) {
            const type = data[offset];
            const channel = data[offset + 1];
            const note = data[offset + 2];
            const velocity = data[offset + 3];
            
            // Read timestamp (4 bytes, little-endian) - FIXED: Handle as signed 32-bit
            let timestamp = data[offset + 4] | 
                           (data[offset + 5] << 8) | 
                           (data[offset + 6] << 16) | 
                           (data[offset + 7] << 24);
            
            // Convert to signed 32-bit integer
            if (timestamp > 0x7FFFFFFF) {
                timestamp -= 0x100000000;
            }
            
            // Handle negative timestamps (preroll) - clamp to 1ms
            if (timestamp < 0) {
                debugLog(`ðŸ” PREROLL: Found negative timestamp ${timestamp}ms, clamping to 1ms`);
                timestamp = 1;
            }
            
            // Skip completely empty events (all zeros)
            if (type === 0 && channel === 0 && note === 0 && velocity === 0 && timestamp === 0) {
                offset += eventSize;
                continue;
            }
            
            // Check if this looks like a valid MIDI event
            const isValidType = (type >= 0 && type <= 2); // NOTE_OFF, NOTE_ON, CC
            const isValidChannel = (channel >= 0 && channel <= 15);
            const isValidNote = (note >= 0 && note <= 127);
            const isValidVelocity = (velocity >= 0 && velocity <= 127);
            const isReasonableTimestamp = (timestamp >= 0 && timestamp < 600000); // Less than 10 minutes
            
            debugLog(`ðŸ” EVENT: type=${type}, ch=${channel}, note=${note}, vel=${velocity}, time=${timestamp}ms`);
            
            if (isValidType && isValidChannel && isValidNote && isValidVelocity && isReasonableTimestamp) {
                candidateEvents.push({
                    type,
                    channel,
                    note,
                    velocity,
                    timestamp
                });
                validEvents++;
                
                // Track timestamp ordering (should generally increase)
                if (timestamp >= lastTimestamp) {
                    timestampIncreases++;
                } else {
                    timestampDecreases++;
                }
                lastTimestamp = timestamp;
                
                debugLog(`ðŸ” VALID EVENT: type=${type} (${type === 1 ? 'NOTE_ON' : type === 2 ? 'NOTE_OFF' : 'CC'}), ch=${channel}, note=${note}, vel=${velocity}, time=${timestamp}ms`);
            } else {
                invalidEvents++;
                debugLog(`ðŸ” INVALID EVENT: type=${type}, ch=${channel}, note=${note}, vel=${velocity}, time=${timestamp}ms`);
                debugLog(`ðŸ”   Checks: type=${isValidType}, ch=${isValidChannel}, note=${isValidNote}, vel=${isValidVelocity}, time=${isReasonableTimestamp}`);
            }
            
            offset += eventSize;
        }
        
        // Score this attempt:
        // - Prefer more valid events
        // - Prefer fewer invalid events  
        // - Prefer mostly increasing timestamps
        // - Prefer having both note-ons AND note-offs
        const noteOns = candidateEvents.filter(e => e.type === 1).length;
        const noteOffs = candidateEvents.filter(e => e.type === 2).length;
        const hasBalancedEvents = Math.min(noteOns, noteOffs) > 0;
        
        const score = validEvents * 100 
                     - invalidEvents * 50 
                     + timestampIncreases * 10 
                     - timestampDecreases * 20
                     + (hasBalancedEvents ? 500 : 0); // Big bonus for having both note-ons and note-offs
        
        debugLog(`ðŸ” DEBUG EVENTS: eventSize=${eventSize}, valid=${validEvents}, invalid=${invalidEvents}, noteOns=${noteOns}, noteOffs=${noteOffs}, score=${score}`);
        
        if (score > bestScore) {
            bestScore = score;
            bestResult = {
                eventSize,
                events: candidateEvents,
                noteOns,
                noteOffs
            };
        }
    }
    
    if (bestResult) {
        debugLog(`ðŸ” DEBUG EVENTS: selected eventSize=${bestResult.eventSize} with ${bestResult.events.length} events (${bestResult.noteOns} note-ons, ${bestResult.noteOffs} note-offs)`);
        
        // Sort events by timestamp
        bestResult.events.sort((a, b) => a.timestamp - b.timestamp);
        
        if (bestResult.events.length > 0) {
            debugLog(`ðŸ” DEBUG EVENTS: timestamp range: ${bestResult.events[0].timestamp}ms to ${bestResult.events[bestResult.events.length-1].timestamp}ms`);
            
            // Log first few events for debugging
            for (let i = 0; i < Math.min(5, bestResult.events.length); i++) {
                const e = bestResult.events[i];
                const typeStr = e.type === 1 ? 'NOTE_ON' : e.type === 2 ? 'NOTE_OFF' : 'CC';
                debugLog(`ðŸ” Event ${i+1}: ${typeStr} ch=${e.channel} note=${e.note} vel=${e.velocity} time=${e.timestamp}ms`);
            }
            
            // Check for note-on/note-off pairing
            const noteStates = new Map(); // key: "channel-note", value: timestamp of note-on
            let unpairedNoteOns = 0;
            let properPairs = 0;
            
            bestResult.events.forEach(event => {
                const key = `${event.channel}-${event.note}`;
                if (event.type === 1) { // NOTE_ON
                    noteStates.set(key, event.timestamp);
                } else if (event.type === 2) { // NOTE_OFF
                    if (noteStates.has(key)) {
                        const noteOnTime = noteStates.get(key);
                        debugLog(`ðŸ” NOTE PAIR: ch=${event.channel} note=${event.note} ON@${noteOnTime}ms OFF@${event.timestamp}ms (duration=${event.timestamp - noteOnTime}ms)`);
                        noteStates.delete(key);
                        properPairs++;
                    } else {
                        debugLog(`ðŸ” ORPHAN NOTE-OFF: ch=${event.channel} note=${event.note} @${event.timestamp}ms (no matching note-on)`);
                    }
                }
            });
            
            // Count remaining unpaired note-ons
            unpairedNoteOns = noteStates.size;
            noteStates.forEach((timestamp, key) => {
                debugLog(`ðŸ” ORPHAN NOTE-ON: ${key} @${timestamp}ms (no matching note-off)`);
            });
            
            debugLog(`ðŸ” NOTE PAIRING: ${properPairs} proper pairs, ${unpairedNoteOns} unpaired note-ons`);
        }
        
        return bestResult.events;
    } else {
        debugLog(`âŒ DEBUG EVENTS: no valid event structure found`);
        return [];
    }
}

// Also add this debugging function to help diagnose the raw data
function debugRawEventData(data, maxEvents = 5) {
    debugLog(`ðŸ” RAW DATA DEBUG: First ${Math.min(maxEvents * 16, data.length)} bytes:`);
    
    for (let eventIndex = 0; eventIndex < maxEvents && eventIndex * 16 < data.length; eventIndex++) {
        const offset = eventIndex * 16;
        const remainingBytes = Math.min(16, data.length - offset);
        
        let hexStr = '';
        let eventStr = '';
        
        for (let i = 0; i < remainingBytes; i++) {
            hexStr += data[offset + i].toString(16).padStart(2, '0') + ' ';
            
            if (i === 0) eventStr += `type=${data[offset + i]} `;
            else if (i === 1) eventStr += `ch=${data[offset + i]} `;
            else if (i === 2) eventStr += `note=${data[offset + i]} `;
            else if (i === 3) eventStr += `vel=${data[offset + i]} `;
            else if (i >= 4 && i <= 7) {
                if (i === 4) {
                    const timestamp = data[offset + 4] | 
                                    (data[offset + 5] << 8) | 
                                    (data[offset + 6] << 16) | 
                                    (data[offset + 7] << 24);
                    eventStr += `time=${timestamp}ms `;
                }
            } else {
                eventStr += `pad=${data[offset + i]} `;
            }
        }
        
        debugLog(`ðŸ” Event ${eventIndex}: [${hexStr.trim()}] ${eventStr}`);
    }
}

        function createMIDIFile(loopsData, filename, bpm) {
            debugLog(`ðŸŽµ DEBUG MIDI: Creating MIDI file: ${filename} at ${bpm} BPM`);
            
            // Count non-empty tracks and create track list
            let trackCount = 0;
            const tracks = [];
            
            for (let i = 1; i <= 4; i++) {
                const loopData = loopsData[i];
                if (loopData && (loopData.mainEvents.length > 0 || loopData.overdubEvents.length > 0)) {
                    if (loopData.mainEvents.length > 0) {
                        tracks.push({
                            name: `Loop ${i} Main`,
                            events: loopData.mainEvents,
                            loopLength: loopData.loopLength || 0,
                            loopGap: loopData.loopGap || 0
                        });
                        trackCount++;
                        debugLog(`ðŸŽµ DEBUG MIDI: Added main track for loop ${i} with ${loopData.mainEvents.length} events (loopLength: ${loopData.loopLength}ms)`);
                    }
                    if (loopData.overdubEvents.length > 0) {
                        tracks.push({
                            name: `Loop ${i} Overdub`,
                            events: loopData.overdubEvents,
                            loopLength: loopData.loopLength || 0,
                            loopGap: loopData.loopGap || 0
                        });
                        trackCount++;
                        debugLog(`ðŸŽµ DEBUG MIDI: Added overdub track for loop ${i} with ${loopData.overdubEvents.length} events (loopLength: ${loopData.loopLength}ms)`);
                    }
                }
            }
            
            if (trackCount === 0) {
                debugLog('âŒ No tracks to save');
                return null;
            }
            
            debugLog(`ðŸŽµ DEBUG MIDI: Creating MIDI with ${trackCount} tracks`);
            
            // Find shortest track for sync reference (but don't apply sync yet)
            const shortestTrackLength = findShortestTrackLength(tracks, bpm);
            
            // Create MIDI file structure
            const midiData = [];
    
            // MIDI Header
            debugLog(`ðŸŽµ DEBUG HEADER: Creating header for ${trackCount} tracks`);
            const headerData = createMIDIHeader(trackCount);
            debugLog(`ðŸŽµ DEBUG HEADER: Created ${headerData.length} byte header`);
            midiData.push(...headerData);
            debugLog(`ðŸŽµ DEBUG MIDI: Added ${headerData.length} byte header`);
            
            // Create tracks with sync info
            tracks.forEach((track, index) => {
                debugLog(`ðŸŽµ DEBUG MIDI: Creating track ${index + 1}: ${track.name}`);
                midiData.push(...createMIDITrack(track, bpm, shortestTrackLength));
            });
            
            debugLog(`ðŸŽµ DEBUG MIDI: Final MIDI file size: ${midiData.length} bytes`);
            
            return new Uint8Array(midiData);
        }

        // Find the shortest track length for sync reference
        function findShortestTrackLength(tracks, bpm) {
            if (tracks.length <= 1) {
                debugLog(`ðŸ”„ SYNC: Only ${tracks.length} track(s), skipping synchronization`);
                return null;
            }
            
            const trackLengths = tracks.map(track => {
                return track.loopLength || 0;
            });
            
            const shortestMs = Math.min(...trackLengths.filter(length => length > 0));
            const shortestTicks = msToTicks(shortestMs, bpm);
            
            debugLog(`ðŸ”„ SYNC: Shortest track reference: ${shortestMs}ms (${shortestTicks} ticks)`);
            
            return { ms: shortestMs, ticks: shortestTicks };
        }

        // Create MIDI header chunk
        function createMIDIHeader(trackCount) {
            debugLog(`ðŸŽµ DEBUG HEADER: Creating header for ${trackCount} tracks, TPQN=${MIDI_TPQN}`);
            
            const header = [];
            
            // "MThd" chunk identifier
            header.push(0x4D, 0x54, 0x68, 0x64);
            
            // Header length (always 6 for format 1)
            header.push(0x00, 0x00, 0x00, 0x06);
            
            // Format type (1 = multiple tracks)
            header.push(0x00, 0x01);
            
            // Number of tracks
            header.push((trackCount >> 8) & 0xFF, trackCount & 0xFF);
            
            // Ticks per quarter note
            header.push((MIDI_TPQN >> 8) & 0xFF, MIDI_TPQN & 0xFF);
            
            debugLog(`ðŸŽµ DEBUG HEADER: Created ${header.length} byte header`);
            return header;
        }

        // Create MIDI track chunk
        function createMIDITrack(track, bpm, shortestTrackRef = null) {
            const trackData = [];
            
            // Track name meta event
            trackData.push(...createMetaEvent(0x03, stringToBytes(track.name)));
            
            // Tempo meta event (only for first track typically, but we'll add to all)
            const microsecondsPerQuarter = Math.round(60000000 / bpm);
            const tempoBytes = [
                (microsecondsPerQuarter >> 16) & 0xFF,
                (microsecondsPerQuarter >> 8) & 0xFF,
                microsecondsPerQuarter & 0xFF
            ];
            trackData.push(...createMetaEvent(0x51, tempoBytes));
            
            // Convert and add MIDI events
            let lastTicks = 0;
            track.events.forEach(event => {
                const ticks = msToTicks(event.timestamp, bpm);
                const deltaTime = ticks - lastTicks;
                lastTicks = ticks;
                
                // Add delta time
                trackData.push(...writeVarLength(deltaTime));
                
                // Add MIDI event
                switch (event.type) {
                    case MIDI_EVENT_NOTE_ON:
                        trackData.push(0x90 | event.channel, event.note, event.velocity);
                        break;
                    case MIDI_EVENT_NOTE_OFF:
                        trackData.push(0x80 | event.channel, event.note, event.velocity);
                        break;
                    case MIDI_EVENT_CC:
                        trackData.push(0xB0 | event.channel, event.note, event.velocity);
                        break;
                }
            });
            
            let endTrackDelta = 0;
            if (track.loopLength && track.loopLength > 0 && track.loopLength < 600000) {
                const loopLengthTicks = msToTicks(track.loopLength, bpm);
                if (loopLengthTicks > lastTicks) {
                    endTrackDelta = loopLengthTicks - lastTicks;
                    debugLog(`ðŸŽµ DEBUG TRACK: Will add ${endTrackDelta} ticks of silence before end of track (${track.loopLength}ms)`);
                } else {
                    debugLog(`ðŸŽµ DEBUG TRACK: No silence needed - events already fill loop length`);
                }
            } else {
                debugLog(`ðŸŽµ DEBUG TRACK: No valid loopLength specified (${track.loopLength}ms)`);
            }

            // Apply sync adjustment if we have a reference and this isn't the shortest track
            if (shortestTrackRef && track.loopLength !== shortestTrackRef.ms) {
                const currentFinalLengthTicks = lastTicks + endTrackDelta;
                const currentFinalLengthMs = ticksToMs(currentFinalLengthTicks, bpm);
                
                // Calculate sync target
                const syncTarget = findSyncTarget(currentFinalLengthMs, shortestTrackRef.ms, shortestTrackRef.ms * 0.1);
                
                if (syncTarget !== currentFinalLengthMs) {
                    const syncTargetTicks = msToTicks(syncTarget, bpm);
                    const adjustment = syncTargetTicks - currentFinalLengthTicks;
                    const adjustmentMs = syncTarget - currentFinalLengthMs;
                    
                    // Apply the adjustment to endTrackDelta
                    const originalDelta = endTrackDelta;
                    endTrackDelta += adjustment;
                    
                    // Ensure we don't go negative
                    if (endTrackDelta < 0) {
                        debugLog(`âš ï¸ SYNC: Track "${track.name}": Sync adjustment would create negative delta (${endTrackDelta}), clamping to 0`);
                        endTrackDelta = 0;
                    }
                    
                    const action = adjustment > 0 ? 'Adding' : 'Removing';
                    debugLog(`ðŸ”„ SYNC: Track "${track.name}": ${currentFinalLengthMs}ms â†’ ${syncTarget}ms (${action} ${Math.abs(adjustmentMs)}ms)`);
                    debugLog(`ðŸ”„ SYNC: Track "${track.name}": ${action} ${Math.abs(adjustment)} ticks for synchronization`);
                    debugLog(`ðŸ”„ SYNC: Track "${track.name}": Final delta: ${originalDelta} â†’ ${endTrackDelta} ticks`);
                } else {
                    debugLog(`ðŸ”„ SYNC: Track "${track.name}": ${currentFinalLengthMs}ms (no adjustment needed)`);
                }
            }

            // End of track (with silence incorporated into the delta time)
            trackData.push(...writeVarLength(endTrackDelta));
            trackData.push(0xFF, 0x2F, 0x00);
                        
                        
                        // Create track chunk
                        const chunk = [];
                        
                        // "MTrk" chunk identifier
                        chunk.push(0x4D, 0x54, 0x72, 0x6B);
                        
            const length = trackData.length;
            debugLog(`ðŸŽµ DEBUG TRACK: Track "${track.name}" data length: ${length} bytes`);

            chunk.push(
                (length >> 24) & 0xFF,
                (length >> 16) & 0xFF,
                (length >> 8) & 0xFF,
                length & 0xFF
            );
                        
            // Track data
            chunk.push(...trackData);
            
            return chunk;
        }

        // Find the closest multiple of the shortest track that's within threshold
        function findSyncTarget(trackMs, shortestMs, thresholdMs) {
            // Calculate which multiple we're closest to
            const exactMultiple = trackMs / shortestMs;
            const lowerMultiple = Math.floor(exactMultiple);
            const upperMultiple = Math.ceil(exactMultiple);
            
            // Check both possibilities
            const lowerTarget = lowerMultiple * shortestMs;
            const upperTarget = upperMultiple * shortestMs;
            
            const lowerDiff = Math.abs(trackMs - lowerTarget);
            const upperDiff = Math.abs(trackMs - upperTarget);
            
            // Choose the closest one that's within threshold
            if (lowerDiff <= thresholdMs && upperDiff <= thresholdMs) {
                // Both are within threshold, choose the closest
                return lowerDiff <= upperDiff ? lowerTarget : upperTarget;
            } else if (lowerDiff <= thresholdMs) {
                return lowerTarget;
            } else if (upperDiff <= thresholdMs) {
                return upperTarget;
            } else {
                // Neither is within threshold, don't adjust
                return trackMs;
            }
        }

        // Create MIDI meta event
        function createMetaEvent(type, data) {
            const event = [];
            event.push(...writeVarLength(0)); // Delta time
            event.push(0xFF); // Meta event
            event.push(type); // Meta type
            event.push(...writeVarLength(data.length)); // Data length
            event.push(...data); // Data
            return event;
        }

        // Convert string to bytes
        function stringToBytes(str) {
            return Array.from(str).map(c => c.charCodeAt(0));
        }

        // Write variable length quantity (MIDI format)
        function writeVarLength(value) {
            const bytes = [];
            
            if (value === 0) {
                return [0];
            }
            
            let temp = value;
            while (temp > 0) {
                bytes.unshift(temp & 0x7F);
                temp >>= 7;
            }
            
            // Set continuation bit on all but last byte
            for (let i = 0; i < bytes.length - 1; i++) {
                bytes[i] |= 0x80;
            }
            
            return bytes;
        }

        // Read variable length quantity
        function readVarLength(data, offset) {
            let value = 0;
            let currentOffset = offset;
            
            while (currentOffset < data.length) {
                const byte = data[currentOffset++];
                value = (value << 7) | (byte & 0x7F);
                if ((byte & 0x80) === 0) {
                    break;
                }
            }
            
            return { value, offset: currentOffset };
        }

        // Parse MIDI file and extract tracks
        function parseMIDIFile(data) {
            debugLog(`ðŸŽµ Parsing MIDI file: ${data.length} bytes`);
            
            let offset = 0;
            
            // Read header
            if (offset + 14 > data.length) {
                throw new Error('Invalid MIDI file: too short');
            }
            
            // Check "MThd"
            if (data[offset] !== 0x4D || data[offset+1] !== 0x54 || 
                data[offset+2] !== 0x68 || data[offset+3] !== 0x64) {
                throw new Error('Invalid MIDI file: bad header');
            }
            offset += 4;
            
            // Header length (should be 6)
            const headerLength = (data[offset] << 24) | (data[offset+1] << 16) | 
                                (data[offset+2] << 8) | data[offset+3];
            offset += 4;
            
            if (headerLength !== 6) {
                throw new Error('Invalid MIDI file: bad header length');
            }
            
            // Format type
            const format = (data[offset] << 8) | data[offset+1];
            offset += 2;
            
            // Number of tracks
            const trackCount = (data[offset] << 8) | data[offset+1];
            offset += 2;
            
            // Ticks per quarter note
            const tpqn = (data[offset] << 8) | data[offset+1];
            offset += 2;
            
            debugLog(`ðŸŽµ MIDI Format: ${format}, Tracks: ${trackCount}, TPQN: ${tpqn}`);
            
            // Parse tracks
            const tracks = [];
            let foundBPM = 120; // Default
            
            for (let trackIndex = 0; trackIndex < trackCount && offset < data.length; trackIndex++) {
                // Check "MTrk"
                if (offset + 8 > data.length) break;
                
                if (data[offset] !== 0x4D || data[offset+1] !== 0x54 || 
                    data[offset+2] !== 0x72 || data[offset+3] !== 0x6B) {
                    debugLog(`âŒ Invalid track ${trackIndex}: bad header`);
                    break;
                }
                offset += 4;
                
                // Track length
                const trackLength = (data[offset] << 24) | (data[offset+1] << 16) | 
                                   (data[offset+2] << 8) | data[offset+3];
                offset += 4;
                
                if (offset + trackLength > data.length) {
                    debugLog(`âŒ Track ${trackIndex}: length exceeds file size`);
                    break;
                }
                
                // Parse track events
                const trackData = data.slice(offset, offset + trackLength);
                const { events, tempo, trackName, maxTicks } = parseMIDITrack(trackData, tpqn);
                
                if (tempo) {
                    foundBPM = tempo;
                    debugLog(`ðŸŽµ Found BPM: ${foundBPM} in track ${trackIndex}`);
                }
                
                if (events.length > 0) {
                    tracks.push({
                        name: trackName || `Track ${trackIndex + 1}`,
                        events: events,
                        maxTicks: maxTicks
                    });
                }
                
                offset += trackLength;
            }
            
            debugLog(`ðŸŽµ Parsed ${tracks.length} tracks with events`);
            
            return { tracks, bpm: foundBPM };
        }

        // Enhanced MIDI track parsing with better duration detection
        function parseMIDITrack(data, tpqn) {
            const events = [];
            let offset = 0;
            let currentTicks = 0;
            let trackName = null;
            let tempo = null;
            let maxTicks = 0; // Track the maximum tick value to determine track length
            
            while (offset < data.length) {
                // Read delta time
                const deltaResult = readVarLength(data, offset);
                const deltaTime = deltaResult.value;
                offset = deltaResult.offset;
                
                currentTicks += deltaTime;
                maxTicks = Math.max(maxTicks, currentTicks);
                
                if (offset >= data.length) break;
                
                const eventByte = data[offset++];
                
                if (eventByte === 0xFF) {
                    // Meta event
                    if (offset >= data.length) break;
                    const metaType = data[offset++];
                    
                    const lengthResult = readVarLength(data, offset);
                    const metaLength = lengthResult.value;
                    offset = lengthResult.offset;
                    
                    if (offset + metaLength > data.length) break;
                    
                    if (metaType === 0x03 && !trackName) {
                        // Track name
                        trackName = String.fromCharCode(...data.slice(offset, offset + metaLength));
                    } else if (metaType === 0x51 && metaLength === 3) {
                        // Tempo
                        const microsecondsPerQuarter = (data[offset] << 16) | 
                                                     (data[offset+1] << 8) | 
                                                     data[offset+2];
                        tempo = Math.round(60000000 / microsecondsPerQuarter);
                    } else if (metaType === 0x2F) {
                        // End of track - update maxTicks
                        maxTicks = Math.max(maxTicks, currentTicks);
                    }
                    
                    offset += metaLength;
                    
                } else if ((eventByte & 0xF0) === 0x90) {
                    // Note on
                    if (offset + 2 > data.length) break;
                    const channel = eventByte & 0x0F;
                    const note = data[offset++];
                    const velocity = data[offset++];
                    
                    if (velocity > 0) {
                        events.push({
                            type: MIDI_EVENT_NOTE_ON,
                            channel,
                            note,
                            velocity,
                            ticks: currentTicks
                        });
                    } else {
                        // Note on with velocity 0 = note off
                        events.push({
                            type: MIDI_EVENT_NOTE_OFF,
                            channel,
                            note,
                            velocity: 64,
                            ticks: currentTicks
                        });
                    }
                    
                } else if ((eventByte & 0xF0) === 0x80) {
                    // Note off
                    if (offset + 2 > data.length) break;
                    const channel = eventByte & 0x0F;
                    const note = data[offset++];
                    const velocity = data[offset++];
                    
                    events.push({
                        type: MIDI_EVENT_NOTE_OFF,
                        channel,
                        note,
                        velocity,
                        ticks: currentTicks
                    });
                    
                } else if ((eventByte & 0xF0) === 0xB0) {
                    // Control change
                    if (offset + 2 > data.length) break;
                    const channel = eventByte & 0x0F;
                    const controller = data[offset++];
                    const value = data[offset++];
                    
                    events.push({
                        type: MIDI_EVENT_CC,
                        channel,
                        note: controller,
                        velocity: value,
                        ticks: currentTicks
                    });
                    
                } else {
                    // Skip other event types for now
                    break;
                }
            }
            
            debugLog(`ðŸŽµ Parsed track: ${events.length} events, maxTicks: ${maxTicks}, tempo: ${tempo}`);
            
            return { events, tempo, trackName, maxTicks };
        }

        // Enhanced MIDI to Loop conversion with proper timing calculation
        function convertMIDIToLoopFormat(events, bpm, tpqn) {
            debugLog(`ðŸŽµ Converting ${events.length} MIDI events to loop format at ${bpm} BPM`);
            
            const loopEvents = events.map(event => ({
                type: event.type,
                channel: event.channel,
                note: event.note,
                velocity: event.velocity,
                timestamp: ticksToMs(event.ticks, bpm)
            }));
            
            // Sort by timestamp
            loopEvents.sort((a, b) => a.timestamp - b.timestamp);
            
            // Calculate loop statistics
            if (loopEvents.length > 0) {
                const firstEvent = loopEvents[0].timestamp;
                const lastEvent = loopEvents[loopEvents.length - 1].timestamp;
                debugLog(`ðŸŽµ Event range: ${firstEvent}ms to ${lastEvent}ms (span: ${lastEvent - firstEvent}ms)`);
                
                // Count event types
                const noteOns = loopEvents.filter(e => e.type === MIDI_EVENT_NOTE_ON).length;
                const noteOffs = loopEvents.filter(e => e.type === MIDI_EVENT_NOTE_OFF).length;
                const ccs = loopEvents.filter(e => e.type === MIDI_EVENT_CC).length;
                debugLog(`ðŸŽµ Event breakdown: ${noteOns} note-ons, ${noteOffs} note-offs, ${ccs} CCs`);
            }
            
            return loopEvents;
        }

        // Calculate loop timing from MIDI track
        function calculateLoopTiming(events, bpm, trackLengthTicks = null, skipQuantization = false) {
            if (events.length === 0) {
                return { loopLength: 0, loopGap: 0 };
            }
            
            // Convert all timestamps to milliseconds and find range
            const timestamps = events.map(e => e.timestamp || ticksToMs(e.ticks || 0, bpm));
            const firstEventTime = Math.min(...timestamps);
            const lastEventTime = Math.max(...timestamps);
            
            // Calculate basic loop length from events
            let loopLength = lastEventTime;
            
            // If we have track length information from MIDI, use it
            if (trackLengthTicks) {
                const trackLengthMs = ticksToMs(trackLengthTicks, bpm);
                loopLength = Math.max(loopLength, trackLengthMs);
                debugLog(`ðŸŽµ Using track length: ${trackLengthMs}ms vs event range: ${lastEventTime}ms`);
            }
            
            // Skip ALL quantization logic for the shortest loop (reference loop)
            if (skipQuantization) {
                debugLog(`ðŸŽ¯ SHORTEST LOOP: Preserving exact timing: ${loopLength}ms (no quantization)`);
            } else {
                // Smart quantization to bar boundaries (only if close and NOT the shortest loop)
                // Assume 4/4 time signature
                const msPerBeat = 60000 / bpm;
                const msPerBar = msPerBeat * 4; // This becomes our "smallest unit" reference
                const threshold = msPerBar * 0.05; // 5% of a bar
                
                // Find the closest multiple of bar length
                const exactBars = loopLength / msPerBar;
                const nearestBars = Math.round(exactBars); // Use round instead of ceil
                const quantizedLength = nearestBars * msPerBar;
                
                // Calculate how far we are from the quantized length
                const difference = Math.abs(loopLength - quantizedLength);
                
                // Only apply quantization if we're within 5% of a bar boundary
                if (difference <= threshold && nearestBars > 0) {
                    loopLength = quantizedLength;
                    debugLog(`ðŸŽµ Quantized loop length to ${nearestBars} bars: ${loopLength}ms (was ${difference.toFixed(1)}ms off)`);
                } else {
                    debugLog(`ðŸŽµ No quantization applied: ${difference.toFixed(1)}ms difference > ${threshold.toFixed(1)}ms threshold`);
                }
            }
            
            // Calculate gap (silence at end)
            const loopGap = Math.max(0, loopLength - lastEventTime);
            
            debugLog(`ðŸŽµ Calculated timing - Length: ${loopLength}ms, Gap: ${loopGap}ms`);
            
            return { loopLength, loopGap };
        }

 // Enhanced createLoopDataFromEvents with proper BPM format
function createLoopDataFromEvents(events, loopNum, bpm, loopTiming = null, isOverdub = false) {
    debugLog(`ðŸ”§ Creating loop data for loop ${loopNum} with ${events.length} events at ${bpm} BPM (overdub: ${isOverdub})`);
    
    const buffer = [];
    
    // Header
    buffer.push(0xAA, 0x55, 0x01, loopNum);
    
    // Convert events to binary format (8 bytes per event to match C structure)
    const eventData = [];
    events.forEach(event => {
        // Each event is 8 bytes: type(1) + channel(1) + note(1) + velocity(1) + timestamp(4)
        eventData.push(
            event.type,
            event.channel,
            event.note,
            event.velocity,
            // Timestamp (4 bytes, little-endian)
            event.timestamp & 0xFF,
            (event.timestamp >> 8) & 0xFF,
            (event.timestamp >> 16) & 0xFF,
            (event.timestamp >> 24) & 0xFF
        );
    });
    
    debugLog(`ðŸ”§ Created ${eventData.length} bytes of event data for ${events.length} events`);
    
    if (isOverdub) {
        // For overdub: main size = 0, overdub size = eventData.length
        buffer.push(0x00, 0x00); // Main macro size (0)
        buffer.push((eventData.length >> 8) & 0xFF, eventData.length & 0xFF); // Overdub size
        buffer.push(...eventData); // Overdub data
    } else {
        // For main: main size = eventData.length, overdub size = 0
        buffer.push((eventData.length >> 8) & 0xFF, eventData.length & 0xFF); // Main macro size
        buffer.push(...eventData); // Main macro data
        buffer.push(0x00, 0x00); // Overdub size (0)
    }
    
    // Transformation settings (7 bytes of zeros)
    for (let i = 0; i < 7; i++) buffer.push(0x00);
    
    // Calculate timing if not provided
    let timing = loopTiming;
    if (!timing) {
        timing = calculateLoopTiming(events, bpm);
    }
    
    // Timing info (8 bytes: 4 for loop_length, 4 for loop_gap)
    const loopLength = Math.round(timing.loopLength);
    const loopGap = Math.round(timing.loopGap);
    
    // Loop length (4 bytes, big-endian)
    buffer.push(
        (loopLength >> 24) & 0xFF,
        (loopLength >> 16) & 0xFF,
        (loopLength >> 8) & 0xFF,
        loopLength & 0xFF
    );
    
    // Loop gap (4 bytes, big-endian)
    buffer.push(
        (loopGap >> 24) & 0xFF,
        (loopGap >> 16) & 0xFF,
        (loopGap >> 8) & 0xFF,
        loopGap & 0xFF
    );
    
    debugLog(`ðŸ”§ Added timing info - Length: ${loopLength}ms, Gap: ${loopGap}ms`);
    
    // BPM info (5 bytes) - FIXED FORMAT
    buffer.push(0x01); // This loop sets BPM (flag byte)
    
    // 4-byte BPM value (to match C code expectation)
    const bpmValue = Math.round(bpm * 100000);
    buffer.push((bpmValue >> 24) & 0xFF);  // High byte
    buffer.push((bpmValue >> 16) & 0xFF);
    buffer.push((bpmValue >> 8) & 0xFF);
    buffer.push(bpmValue & 0xFF);          // Low byte
    
    debugLog(`ðŸ”§ Added BPM info - ${bpm} BPM (stored as ${bpmValue})`);
    debugLog(`ðŸ”§ Final loop data: ${buffer.length} bytes total`);
    
    return new Uint8Array(buffer);
}

        // Extract BPM from filename
        function extractBPMFromFilename(filename) {
            const match = filename.match(/(\d+(?:\.\d+)?)(?:\.midi?)?$/i);
            if (match) {
                const bpm = parseFloat(match[1]);
                if (bpm >= 60 && bpm <= 300) { // Reasonable BPM range
                    return bpm;
                }
            }
            return null;
        }

        // Check if a track can be assigned as overdub to a loop
        function canAssignAsOverdub(trackLength, loopNum) {
            // Check if there's pending main content OR current loaded main content
            const pendingMain = pendingAssignments[loopNum] && pendingAssignments[loopNum].main;
            const currentMain = currentLoopContents[loopNum];
            
            // Can assign overdub if loop has any main content (no length restriction)
            return !!(pendingMain || currentMain);
        }

        // Get track length in milliseconds
        function getTrackLength(track, bpm) {
            if (!track.events || track.events.length === 0) return 0;
            
            const timing = calculateLoopTiming(
                track.events.map(e => ({...e, timestamp: ticksToMs(e.ticks, bpm)})), 
                bpm, 
                track.maxTicks
            );
            
            return timing.loopLength;
        }

        // Update track selection area based on selected file
        function updateTrackSelection() {
            const trackButtonsGrid = document.getElementById('trackButtonsGrid');
            const loopAssignmentArea = document.getElementById('loopAssignmentArea');
            
            if (selectedFile === null || !loadedFiles[selectedFile]) {
                trackButtonsGrid.innerHTML = '<div style="padding: 20px; text-align: center; color: #718096; font-style: italic;">Select a multi-track MIDI file to see track options</div>';
                loopAssignmentArea.style.display = 'none';
                return;
            }
            
            const file = loadedFiles[selectedFile];
            
            if (file.tracks.length <= 1) {
                trackButtonsGrid.innerHTML = '<div style="padding: 20px; text-align: center; color: #718096; font-style: italic;">Selected file has only one track - use "Load All Tracks"</div>';
                loopAssignmentArea.style.display = 'none';
                return;
            }
            
            // Clear existing buttons
            trackButtonsGrid.innerHTML = '';
            
            // Create buttons for each track
            file.tracks.forEach((track, trackIndex) => {
                const trackLength = getTrackLength(track, file.bpm);
                const trackNumber = trackIndex + 1;
                const trackTitle = track.name || `Untitled Track`;
                
                const button = document.createElement('button');
                button.className = 'track-selection-btn';
                button.onclick = () => selectTrackForAdvancedAssignment(trackIndex);
                button.id = `trackBtn${trackIndex}`;
                
                button.innerHTML = `
                    <div class="track-info">Track ${trackNumber}</div>
                    <div class="track-details">${trackTitle} â€¢ ${Math.round(trackLength)}ms</div>
                `;
                
                trackButtonsGrid.appendChild(button);
            });
            
            // Always show assignment area for multi-track files
            loopAssignmentArea.style.display = 'block';
            
            // Auto-select the first track for assignment (only if no track is currently selected)
            if (file.tracks.length > 0 && selectedTrack === null) {
                selectTrackForAdvancedAssignment(0);
                debugLog(`ðŸŽ¯ Auto-selected first track for assignment: "${file.tracks[0].name}"`);
            } else if (selectedTrack !== null && selectedTrack < file.tracks.length) {
                // Update assignment buttons for currently selected track
                const track = file.tracks[selectedTrack];
                const trackLength = getTrackLength(track, file.bpm);
                updateAssignmentButtons(trackLength);
            } else {
                // Initialize assignment buttons in disabled state if no valid track selected
                initializeAssignmentButtons();
            }
        }

        // Update assignment button labels and styling based on current content and pending assignments
        function updateAssignmentButtonLabels() {
            // Update main loop buttons
            for (let i = 1; i <= 4; i++) {
                const btn = document.getElementById(`assignMain${i}`);
                
                // Check if there's a pending assignment
                const pendingMain = pendingAssignments[i] && pendingAssignments[i].main;
                
                if (pendingMain) {
                    // Show pending assignment with different styling
                    btn.classList.add('track-style');
                    btn.style.background = '#fbbf24'; // Yellow to indicate pending
                    btn.style.borderColor = '#fbbf24';
                    btn.style.color = 'white';
                    btn.title = 'Click to remove pending assignment';
                    btn.innerHTML = `
                        <div class="track-info">${pendingMain.trackInfo.displayName} (pending) âœ•</div>
                        <div class="track-details">${pendingMain.trackInfo.title} â€¢ ${Math.round(pendingMain.trackInfo.length)}ms</div>
                    `;
                } else if (currentLoopContents[i]) {
                    // Show loaded content with normal styling
                    btn.classList.add('track-style');
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                    btn.title = '';
                    btn.innerHTML = `
                        <div class="track-info">${currentLoopContents[i].displayName}</div>
                        <div class="track-details">${currentLoopContents[i].title} â€¢ ${Math.round(currentLoopContents[i].length)}ms</div>
                    `;
                } else {
                    // Reset to default button appearance
                    btn.classList.remove('track-style', 'selected');
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                    btn.title = '';
                    btn.innerHTML = `Loop ${i}`;
                }
            }
            
            // Update overdub buttons
            for (let i = 1; i <= 4; i++) {
                const btn = document.getElementById(`assignOverdub${i}`);
                
                // Check if there's a pending assignment
                const pendingOverdub = pendingAssignments[i] && pendingAssignments[i].overdub;
                
                if (pendingOverdub) {
                    // Show pending assignment with different styling
                    btn.classList.add('track-style');
                    btn.style.background = '#fbbf24'; // Yellow to indicate pending
                    btn.style.borderColor = '#fbbf24';
                    btn.style.color = 'white';
                    btn.title = 'Click to remove pending assignment';
                    btn.innerHTML = `
                        <div class="track-info">${pendingOverdub.trackInfo.displayName} (pending) âœ•</div>
                        <div class="track-details">${pendingOverdub.trackInfo.title} â€¢ ${Math.round(pendingOverdub.trackInfo.length)}ms</div>
                    `;
                } else if (currentOverdubContents[i]) {
                    // Show loaded content with normal styling
                    btn.classList.add('track-style');
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                    btn.title = '';
                    btn.innerHTML = `
                        <div class="track-info">${currentOverdubContents[i].displayName}</div>
                        <div class="track-details">${currentOverdubContents[i].title} â€¢ ${Math.round(currentOverdubContents[i].length)}ms</div>
                    `;
                } else {
                    // Reset to default button appearance
                    btn.classList.remove('track-style', 'selected');
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                    btn.title = '';
                    btn.innerHTML = `Overdub ${i}`;
                }
            }
        }

        // Initialize assignment buttons in disabled state
        function initializeAssignmentButtons() {
            // Update labels first
            updateAssignmentButtonLabels();
            
            // Handle button states based on whether they have pending assignments
            for (let i = 1; i <= 4; i++) {
                const mainBtn = document.getElementById(`assignMain${i}`);
                const overdubBtn = document.getElementById(`assignOverdub${i}`);
                
                // Main buttons: keep enabled if pending, disable if empty
                const hasPendingMain = pendingAssignments[i] && pendingAssignments[i].main;
                if (hasPendingMain) {
                    mainBtn.classList.remove('available');
                    mainBtn.disabled = false; // Keep enabled for removal
                } else {
                    mainBtn.classList.remove('available');
                    mainBtn.disabled = true;
                    mainBtn.title = 'Select a track first';
                }
                
                // Overdub buttons: keep enabled if pending, disable if empty
                const hasPendingOverdub = pendingAssignments[i] && pendingAssignments[i].overdub;
                if (hasPendingOverdub) {
                    overdubBtn.classList.remove('available');
                    overdubBtn.disabled = false; // Keep enabled for removal
                } else {
                    overdubBtn.classList.remove('available');
                    overdubBtn.disabled = true;
                    overdubBtn.title = 'Select a track first';
                }
            }
            
            // Update tooltips for pending assignments
            updatePendingAssignmentTooltips(selectedTrack !== null);
            
            // Update load assignments button
            updateLoadAssignmentsButtonState();
        }

        // Select track for advanced assignment
        function selectTrackForAdvancedAssignment(trackIndex) {
            const file = loadedFiles[selectedFile];
            const track = file.tracks[trackIndex];
            const trackLength = getTrackLength(track, file.bpm);
            
            // Update selected track
            selectedTrack = trackIndex;
            
            // Update button states
            const trackButtons = document.querySelectorAll('.track-selection-btn');
            trackButtons.forEach((btn, index) => {
                if (index === trackIndex) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
            
            // Update assignment button states
            updateAssignmentButtons(trackLength);
            
            showStatus(`Track "${track.name}" selected for assignment`, 'success');
            debugLog(`âœ… Selected track ${trackIndex + 1}: "${track.name}" for advanced assignment`);
        }

        // Update assignment button states based on track compatibility
        function updateAssignmentButtons(trackLength) {
            // Main track buttons - always available when track is selected
            for (let i = 1; i <= 4; i++) {
                const btn = document.getElementById(`assignMain${i}`);
                btn.classList.add('available');
                btn.disabled = false;
                btn.title = `Assign as main track to Loop ${i}`;
            }
            
            // Overdub buttons - only available if loop has main content
            for (let i = 1; i <= 4; i++) {
                const btn = document.getElementById(`assignOverdub${i}`);
                const canOverdub = canAssignAsOverdub(trackLength, i);
                
                if (canOverdub) {
                    btn.classList.add('available');
                    btn.disabled = false;
                    btn.title = `Assign as overdub to Loop ${i}`;
                } else {
                    btn.classList.remove('available');
                    btn.disabled = true;
                    btn.title = `Loop ${i} has no main content`;
                }
            }
        }
		
					// Load overdub data to device via HID (overdub-only, preserves main loop)
			async function loadOverdubData(data, loopNum) {
				const totalPackets = Math.ceil(data.length / HID_CHUNK_SIZE);
				
				// Send start packet (using overdub-specific command)
				const startData = new Uint8Array(4);
				startData[0] = totalPackets & 0xFF;
				startData[1] = (totalPackets >> 8) & 0xFF;
				startData[2] = data.length & 0xFF;
				startData[3] = (data.length >> 8) & 0xFF;
				
				await sendHIDPacket(HID_CMD_LOAD_OVERDUB_START, loopNum, 0, startData);
				
				// Send data packets (same as regular loading)
				for (let packet = 0; packet < totalPackets; packet++) {
					const offset = packet * HID_CHUNK_SIZE;
					const chunkLen = Math.min(HID_CHUNK_SIZE, data.length - offset);
					const chunkData = data.subarray(offset, offset + chunkLen);
					
					const packetData = new Uint8Array(4 + chunkLen);
					packetData[0] = packet & 0xFF;
					packetData[1] = (packet >> 8) & 0xFF;
					packetData[2] = chunkLen & 0xFF;
					packetData[3] = (chunkLen >> 8) & 0xFF;
					packetData.set(chunkData, 4);
					
					await sendHIDPacket(HID_CMD_LOAD_CHUNK, loopNum, 0, packetData);
					
					// Small delay between packets
					await new Promise(resolve => setTimeout(resolve, 10));
				}
				
				// Send end packet
				await sendHIDPacket(HID_CMD_LOAD_END, loopNum, 0);
				
				// Wait a bit for the device to process
				await new Promise(resolve => setTimeout(resolve, 50));
			}

        // Assign selected track to loop (storage only, not loading)
        async function assignSelectedTrack(loopNum, isOverdub) {
            // Check if there's already a pending assignment for this slot
            const existingAssignment = pendingAssignments[loopNum] && 
                                     (isOverdub ? pendingAssignments[loopNum].overdub : pendingAssignments[loopNum].main);
            
            if (existingAssignment) {
                // If NO track is selected, remove the pending assignment
                if (selectedTrack === null || selectedFile === null) {
                    // Remove the existing pending assignment
                    if (isOverdub) {
                        pendingAssignments[loopNum].overdub = null;
                    } else {
                        // If removing main assignment, also remove its overdub
                        pendingAssignments[loopNum].main = null;
                        if (pendingAssignments[loopNum].overdub) {
                            pendingAssignments[loopNum].overdub = null;
                            debugLog(`ðŸ—‘ï¸ Also removed corresponding overdub assignment from Loop ${loopNum}`);
                        }
                    }
                    
                    // Clean up empty assignment objects
                    if (pendingAssignments[loopNum] && 
                        !pendingAssignments[loopNum].main && 
                        !pendingAssignments[loopNum].overdub) {
                        delete pendingAssignments[loopNum];
                    }
                    
                    const assignmentType = isOverdub ? 'overdub' : 'main';
                    showStatus(`Removed pending assignment from Loop ${loopNum} ${assignmentType}`, 'success');
                    debugLog(`ðŸ—‘ï¸ Removed pending assignment from Loop ${loopNum} ${assignmentType}`);
                    
                    // Update button labels and load button state
                    updateAssignmentButtonLabels();
                    updateLoadAssignmentsButtonState();
                    return;
                }
                // If a track IS selected, continue to replace - but validate timing for overdubs
                debugLog(`ðŸ”„ Attempting to replace pending assignment in Loop ${loopNum} ${isOverdub ? 'overdub' : 'main'}`);
            }
            
            // If no track is selected and no existing assignment, just return
            if (selectedTrack === null || selectedFile === null) {
                showStatus('No track selected', 'error');
                return;
            }
            
            // Validate overdub timing (for both new assignments and replacements)
            if (isOverdub) {
                const file = loadedFiles[selectedFile];
                const track = file.tracks[selectedTrack];
                const trackLength = getTrackLength(track, file.bpm);
                
                if (!canAssignAsOverdub(trackLength, loopNum)) {
                    if (existingAssignment) {
                        showStatus('Cannot replace overdub - loop has no main content', 'error');
                    } else {
                        showStatus('Cannot assign as overdub - loop has no main content', 'error');
                    }
                    return;
                }
            }
            
            // Store the assignment
            if (!pendingAssignments[loopNum]) {
                pendingAssignments[loopNum] = { main: null, overdub: null };
            }
            
            const file = loadedFiles[selectedFile];
            const track = file.tracks[selectedTrack];
            const trackNumber = selectedTrack + 1;
            const trackTitle = track.name || `Untitled Track`;
            const trackLength = getTrackLength(track, file.bpm);
            
            const assignmentInfo = {
                fileIndex: selectedFile,
                trackIndex: selectedTrack,
                trackInfo: {
                    length: trackLength,
                    name: track.name,
                    displayName: `Track ${trackNumber}`,
                    title: trackTitle
                }
            };
            
            if (isOverdub) {
                pendingAssignments[loopNum].overdub = assignmentInfo;
                const action = existingAssignment ? 'Replaced' : 'Assigned';
                showStatus(`${action} "${track.name}" to Loop ${loopNum} overdub (pending load)`, 'success');
                debugLog(`ðŸ“‹ ${action} track ${trackNumber} "${track.name}" to Loop ${loopNum} overdub (pending)`);
            } else {
                pendingAssignments[loopNum].main = assignmentInfo;
                const action = existingAssignment ? 'Replaced' : 'Assigned';
                showStatus(`${action} "${track.name}" to Loop ${loopNum} main (pending load)`, 'success');
                debugLog(`ðŸ“‹ ${action} track ${trackNumber} "${track.name}" to Loop ${loopNum} main (pending)`);
            }
            
            // Update button labels to show assignments
            updateAssignmentButtonLabels();
            
            // Update load button state
            updateLoadAssignmentsButtonState();
            
            // Clear selection after assignment
            clearTrackSelection();
        }

        // Update load assignments button state
        function updateLoadAssignmentsButtonState() {
            const loadBtn = document.getElementById('loadAssignmentsBtn');
            
            // Check if there are any pending assignments
            let hasPendingAssignments = false;
            for (let i = 1; i <= 4; i++) {
                if (pendingAssignments[i] && 
                    (pendingAssignments[i].main || pendingAssignments[i].overdub)) {
                    hasPendingAssignments = true;
                    break;
                }
            }
            
            if (hasPendingAssignments) {
                loadBtn.disabled = false;
                loadBtn.style.opacity = '1';
                loadBtn.style.boxShadow = '0 0 10px rgba(5, 150, 105, 0.5)';
            } else {
                loadBtn.disabled = true;
                loadBtn.style.opacity = '0.5';
                loadBtn.style.boxShadow = 'none';
            }
        }

        // Load all assigned tracks to device
        async function loadAssignedTracksToDevice() {
            if (!(await ensureConnection())) {
                return;
            }
            
            // Count total operations for progress tracking
            let totalOperations = 0;
            const assignmentList = []; // Build list of assignments to process
            
            for (let i = 1; i <= 4; i++) {
                if (pendingAssignments[i]) {
                    if (pendingAssignments[i].main) {
                        totalOperations++;
                        assignmentList.push({
                            loopNum: i,
                            isOverdub: false,
                            assignment: pendingAssignments[i].main
                        });
                    }
                    if (pendingAssignments[i].overdub) {
                        totalOperations++;
                        assignmentList.push({
                            loopNum: i,
                            isOverdub: true,
                            assignment: pendingAssignments[i].overdub
                        });
                    }
                }
            }
            
            if (totalOperations === 0) {
                showStatus('No track assignments to load', 'error');
                return;
            }
            
            debugLog(`ðŸ“¤ Loading ${totalOperations} assigned tracks to device`);
            
            try {
                document.getElementById('loadStatus').classList.add('active');
                updateLoadProgress(0);
                
                // Find shortest track among assigned tracks
                const assignedTracks = assignmentList.map(item => {
                    const file = loadedFiles[item.assignment.fileIndex];
                    return file.tracks[item.assignment.trackIndex];
                });
                const shortestTrackIndex = findShortestTrackIndex(assignedTracks, loadedFiles[assignmentList[0].assignment.fileIndex].bpm);
                
                let loadedCount = 0;
                
                // Load assignments in loop order
                for (const item of assignmentList) {
                    const { loopNum, isOverdub, assignment } = item;
                    const { fileIndex, trackIndex } = assignment;
                    const file = loadedFiles[fileIndex];
                    const track = file.tracks[trackIndex];
                    
                    // Check if this is the shortest track (using the index in assignmentList)
                    const currentAssignmentIndex = assignmentList.indexOf(item);
                    const skipQuantization = currentAssignmentIndex === shortestTrackIndex;
                    
                    await loadSingleTrackToLoop(track, trackIndex, loopNum, isOverdub, file.bpm, skipQuantization);
                    
                    // Update current contents and clear pending
                    if (isOverdub) {
                        currentOverdubContents[loopNum] = assignment.trackInfo;
                    } else {
                        currentLoopContents[loopNum] = assignment.trackInfo;
                    }
                    
                    loadedCount++;
                    updateLoadProgress((loadedCount / totalOperations) * 100);
                    debugLog(`ðŸ“¤ Loaded assigned ${isOverdub ? 'overdub' : 'main'} track "${track.name}" to loop ${loopNum}`);
                }
                
                // Clear all pending assignments
                pendingAssignments = {};
                
                // Update button labels to reflect loaded content
                updateAssignmentButtonLabels();
                updateLoadAssignmentsButtonState();
                
                document.getElementById('loadStatus').classList.remove('active');
                showStatus(`Successfully loaded ${loadedCount} assigned tracks to device!`, 'success');
                debugLog(`âœ… Load assignments complete - ${loadedCount} tracks loaded`);
                
            } catch (error) {
                document.getElementById('loadStatus').classList.remove('active');
                showStatus(`Load failed: ${error.message}`, 'error');
                debugLog(`âŒ Load assignments failed: ${error.message}`);
            }
        }
        
        function clearTrackSelection() {
            selectedTrack = null;
            
            // Clear button selections
            const trackButtons = document.querySelectorAll('.track-selection-btn');
            trackButtons.forEach(btn => btn.classList.remove('selected'));
            
            // Initialize assignment buttons in disabled state
            initializeAssignmentButtons();
        }

        // Update tooltips for pending assignments based on track selection state
        function updatePendingAssignmentTooltips(hasTrackSelected) {
            for (let i = 1; i <= 4; i++) {
                const mainBtn = document.getElementById(`assignMain${i}`);
                const overdubBtn = document.getElementById(`assignOverdub${i}`);
                
                const hasPendingMain = pendingAssignments[i] && pendingAssignments[i].main;
                const hasPendingOverdub = pendingAssignments[i] && pendingAssignments[i].overdub;
                
                if (hasPendingMain) {
                    if (hasTrackSelected) {
                        mainBtn.title = 'Click to replace pending assignment with selected track';
                    } else {
                        mainBtn.title = 'Click to remove pending assignment (no track selected)';
                    }
                }
                
                if (hasPendingOverdub) {
                    if (hasTrackSelected) {
                        overdubBtn.title = 'Click to replace pending assignment with selected track';
                    } else {
                        overdubBtn.title = 'Click to remove pending assignment (no track selected)';
                    }
                }
            }
        }

        // Load specific track to specific loop with assignment
        async function loadTrackToLoop(fileIndex, trackIndex, loopNum, isOverdub = false) {
            if (!loadedFiles[fileIndex] || !loadedFiles[fileIndex].tracks[trackIndex]) {
                showStatus('Invalid track selection', 'error');
                return;
            }
            
            if (!(await ensureConnection())) {
                return;
            }
            
            const file = loadedFiles[fileIndex];
            const track = file.tracks[trackIndex];
            
            debugLog(`ðŸ“¤ Loading track ${trackIndex + 1} "${track.name}" to Loop ${loopNum} (${isOverdub ? 'overdub' : 'main'})`);
            
            try {
                document.getElementById('loadStatus').classList.add('active');
                updateLoadProgress(10);
                
                // Convert MIDI events to loop format
                const events = convertMIDIToLoopFormat(track.events, file.bpm, MIDI_TPQN);
                updateLoadProgress(30);
                
                // Calculate timing (individual loads don't skip quantization)
                const timing = calculateLoopTiming(events, file.bpm, track.maxTicks, false);
                updateLoadProgress(50);
                
                // Create loop data
                const loopData = createLoopDataFromEvents(events, loopNum, file.bpm, timing, isOverdub);
                updateLoadProgress(70);
                
                // Send to device
                await loadLoopData(loopData, loopNum);
                updateLoadProgress(100);
                
                // Update current loop/overdub contents tracking
                const trackNumber = trackIndex + 1;
                const trackTitle = track.name || `Untitled Track`;
                const trackInfo = {
                    length: timing.loopLength,
                    name: track.name,
                    displayName: `Track ${trackNumber}`,
                    title: trackTitle
                };
                
                if (isOverdub) {
                    currentOverdubContents[loopNum] = trackInfo;
                } else {
                    currentLoopContents[loopNum] = trackInfo;
                }
                
                // Update button labels to reflect new content
                updateAssignmentButtonLabels();
                
                document.getElementById('loadStatus').classList.remove('active');
                showStatus(`Successfully loaded "${track.name}" to Loop ${loopNum} (${isOverdub ? 'overdub' : 'main'})`, 'success');
                
                debugLog(`âœ… Load complete - Loop ${loopNum}: ${events.length} events, ${timing.loopLength}ms total`);
                
                // Clear highlighting
                clearTrackSelection();
                
            } catch (error) {
                document.getElementById('loadStatus').classList.remove('active');
                showStatus(`Load failed: ${error.message}`, 'error');
                debugLog(`âŒ Load failed: ${error.message}`);
            }
        }

        // Ensure connection (auto-connect if needed)
        async function ensureConnection() {
            if (isConnected && hidDevice) {
                return true;
            }
            return await connectHID();
        }

        // Connect to HID device
        async function connectHID() {
            try {
                debugLog('ðŸ” Requesting HID device access...');
                
                const devices = await navigator.hid.requestDevice({
                    filters: [
                        { vendorId: 0xFEED },
                        { vendorId: 0x1209 },
                    ]
                });

                if (devices.length === 0) {
                    showStatus('No HID device selected', 'error');
                    return false;
                }

                debugLog(`ðŸ“± Found ${devices.length} devices:`);
                
                let selectedDevice = null;
                
                for (let i = 0; i < devices.length; i++) {
                    const device = devices[i];
                    debugLog(`  Device ${i}: ${device.productName || 'Unknown'}`);
                    debugLog(`    Vendor ID: 0x${device.vendorId.toString(16).toUpperCase()}`);
                    debugLog(`    Product ID: 0x${device.productId.toString(16).toUpperCase()}`);
                    debugLog(`    Collections: ${device.collections.length}`);
                    
                    let hasRawHID = false;
                    device.collections.forEach((collection, colIndex) => {
                        debugLog(`      Collection ${colIndex}: Usage Page 0x${collection.usagePage.toString(16)}, Usage 0x${collection.usage.toString(16)}`);
                        
                        if (collection.usagePage === 0xFF60 || collection.usagePage === 65376) {
                            debugLog(`        âœ… Found Raw HID interface!`);
                            hasRawHID = true;
                        }
                        
                        if (collection.usagePage === 0xFF60 && collection.usage === 0x61) {
                            debugLog(`        âœ… Found VIA Raw HID interface!`);
                            hasRawHID = true;
                        }
                    });
                    
                    if (hasRawHID && !selectedDevice) {
                        selectedDevice = device;
                        debugLog(`    âœ… Selected this device for Raw HID communication`);
                    }
                }

                if (!selectedDevice) {
                    selectedDevice = devices[0];
                    debugLog(`    âš ï¸ No Raw HID interface found, trying first device anyway`);
                }

                hidDevice = selectedDevice;
                debugLog(`ðŸ“± Selected device: ${hidDevice.productName || 'Unknown'}`);

                await hidDevice.open();
                debugLog('ðŸ”“ HID device opened successfully');
                
                hidDevice.addEventListener('inputreport', handleHIDInputReport);
                
                isConnected = true;
                updateConnectionStatus();
                updateDeviceLists(); // Update USB fix box visibility
                showStatus(`Connected to ${hidDevice.productName || 'HID Device'}`, 'success');
                
                return true;
                
            } catch (error) {
                debugLog(`âŒ HID connection failed: ${error.message}`);
                showStatus(`Connection failed: ${error.message}`, 'error');
                return false;
            }
        }

        // Send HID packet
        async function sendHIDPacket(command, macroNum, status, data = null) {
            if (!hidDevice || !isConnected) {
                throw new Error('HID device not connected');
            }

            const packet = new Uint8Array(HID_PACKET_SIZE);
            
            packet[0] = HID_MANUFACTURER_ID;
            packet[1] = HID_SUB_ID;
            packet[2] = HID_DEVICE_ID;
            packet[3] = command;
            packet[4] = macroNum;
            packet[5] = status;
            
            if (data && data.length > 0) {
                const copyLen = Math.min(data.length, HID_DATA_SIZE);
                packet.set(data.subarray(0, copyLen), HID_HEADER_SIZE);
            }
            
            debugLog(`ðŸ“¤ Sending HID packet: cmd=${command}, macro=${macroNum}, status=${status}`);
            
            try {
                await hidDevice.sendReport(0, packet);
                debugLog(`âœ… Successfully sent with report ID 0`);
                return;
            } catch (error) {
                debugLog(`âŒ Failed with report ID 0: ${error.message}`);
                
                try {
                    await hidDevice.sendFeatureReport(0, packet);
                    debugLog(`âœ… Successfully sent as feature report`);
                    return;
                } catch (err2) {
                    debugLog(`âŒ Failed with feature report: ${err2.message}`);
                    throw error;
                }
            }
        }

        // Handle incoming HID reports
        function handleHIDInputReport(event) {
            const data = new Uint8Array(event.data.buffer);
            
            debugLog(`ðŸ“¥ Received HID report (${data.length} bytes): [${Array.from(data.slice(0, 10)).join(', ')}...]`);
            
            if (data.length !== HID_PACKET_SIZE) {
                debugLog(`âš ï¸ Wrong packet size: expected ${HID_PACKET_SIZE}, got ${data.length}`);
                return;
            }
            
            if (data[0] !== HID_MANUFACTURER_ID || 
                data[1] !== HID_SUB_ID || 
                data[2] !== HID_DEVICE_ID) {
                debugLog(`âš ï¸ Wrong packet header: expected [${HID_MANUFACTURER_ID}, ${HID_SUB_ID}, ${HID_DEVICE_ID}], got [${data[0]}, ${data[1]}, ${data[2]}]`);
                return;
            }
            
            const command = data[3];
            const macroNum = data[4];
            const status = data[5];
            
            debugLog(`ðŸ“¥ Valid HID packet: cmd=${command}, macro=${macroNum}, status=${status}`);
            
			switch (command) {
				case HID_CMD_SAVE_START:
					handleSaveStart(macroNum, status, data.subarray(HID_HEADER_SIZE));
					break;
				case HID_CMD_SAVE_CHUNK:
					handleSaveChunk(macroNum, status, data.subarray(HID_HEADER_SIZE));
					break;
				case HID_CMD_SAVE_END:
					handleSaveEnd(macroNum, status);
					break;
				case HID_CMD_LOAD_START:
				case HID_CMD_LOAD_OVERDUB_START:
				case HID_CMD_LOAD_END:
					debugLog(`âœ… Device acknowledged: ${command === HID_CMD_LOAD_START ? 'Load Start' : 
													   command === HID_CMD_LOAD_OVERDUB_START ? 'Overdub Load Start' : 'Load Complete'}`);
					if (command === HID_CMD_LOAD_END) {
						document.getElementById('loadStatus').classList.remove('active');
						if (status === 0) {
							if (macroNum === 0) {
								showStatus(`Successfully loaded all loops`, 'success');
							} else {
								showStatus(`Successfully loaded to Loop ${macroNum}`, 'success');
							}
						} else {
							if (macroNum === 0) {
								showStatus(`Failed to load all loops`, 'error');
							} else {
								showStatus(`Failed to load to Loop ${macroNum}`, 'error');
							}
						}
					}
					break;
				// ThruLoop commands (0xB0-0xB5 range)
				case 0xB0: // HID_CMD_SET_LOOP_CONFIG
				case 0xB1: // HID_CMD_SET_MAIN_LOOP_CCS  
				case 0xB2: // HID_CMD_SET_OVERDUB_CCS
				case 0xB3: // HID_CMD_SET_NAVIGATION_CONFIG
				case 0xB4: // HID_CMD_GET_ALL_CONFIG
				case 0xB5: // HID_CMD_RESET_LOOP_CONFIG
					// Route ThruLoop responses to the ThruLoop handler
					thruloopConfig.handleResponse(data);
					break;
				// Keyboard commands (0xB6-0xBB range)
				case 0xB6: // HID_CMD_SET_KEYBOARD_CONFIG
				case 0xB7: // HID_CMD_GET_KEYBOARD_CONFIG  
				case 0xB8: // HID_CMD_RESET_KEYBOARD_CONFIG
				case 0xB9: // HID_CMD_SAVE_KEYBOARD_SLOT
				case 0xBA: // HID_CMD_LOAD_KEYBOARD_SLOT
					// Route keyboard responses to the keyboard handler
					keyboardConfig.handleResponse(data);
					break;
				case 0xBB: // HID_CMD_SET_KEYBOARD_CONFIG_ADVANCED
					// Route advanced keyboard responses to the keyboard handler
					keyboardConfig.handleResponse(data);
					break;
				default:
					debugLog(`â“ Unknown command: ${command}`);
					break;
			}
        }

        // Handle save start response
        function handleSaveStart(macroNum, status, data) {
            if (status !== 0) {
                if (pendingSaveAll) {
                    debugLog(`âš ï¸ Loop ${macroNum} is empty - skipping`);
                    currentTransfer.active = false;
                    return;
                }
                showStatus(`Loop ${macroNum} is empty or error occurred`, 'error');
                document.getElementById('saveStatus').classList.remove('active');
                return;
            }
            
            if (data.length >= 4) {
                const totalPackets = data[0] | (data[1] << 8);
                const totalSize = data[2] | (data[3] << 8);
                
                currentTransfer.expectedPackets = totalPackets;
                currentTransfer.receivedPackets = 0;
                currentTransfer.totalSize = totalSize;
                currentTransfer.receivedData = [];
                
                if (!pendingSaveAll) {
                    currentTransfer.fileName = `loop${macroNum}_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.midi`;
                    document.getElementById('saveStatus').classList.add('active');
                }
                
                debugLog(`ðŸ“‹ Save transfer setup: ${totalPackets} packets, ${totalSize} bytes`);
                updateSaveProgress(0);
            }
        }

        // Handle save chunk response
        function handleSaveChunk(macroNum, status, data) {
            if (!currentTransfer.active || currentTransfer.loopNum !== macroNum) {
                return;
            }
            
            if (data.length >= 4) {
                const packetNum = data[0] | (data[1] << 8);
                const chunkLen = data[2] | (data[3] << 8);
                
                if (chunkLen > 0 && data.length >= 4 + chunkLen) {
                    const chunkData = data.subarray(4, 4 + chunkLen);
                    currentTransfer.receivedData.push(...chunkData);
                    currentTransfer.receivedPackets++;
                    
                    const progress = (currentTransfer.receivedPackets / currentTransfer.expectedPackets) * 100;
                    updateSaveProgress(progress);
                    
                    debugLog(`ðŸ“¦ Received chunk ${currentTransfer.receivedPackets}/${currentTransfer.expectedPackets} (${progress.toFixed(1)}%)`);
                }
            }
        }

        // Floating progress bar functions
        function showFloatingProgress(title = "Processing MIDI File...", text = "Initializing...") {
            const floatingProgress = document.getElementById('floatingProgress');
            const titleEl = document.getElementById('floatingProgressTitle');
            const textEl = document.getElementById('floatingProgressText');
            const fillEl = document.getElementById('floatingProgressFill');
            
            titleEl.textContent = title;
            textEl.innerHTML = `<span class="floating-progress-spinner"></span>${text}`;
            fillEl.style.width = '0%';
            floatingProgress.classList.add('active');
            
            debugLog(`ðŸŽ¯ Floating progress: ${title} - ${text}`);
        }

        function updateFloatingProgress(percent, text) {
            const textEl = document.getElementById('floatingProgressText');
            const fillEl = document.getElementById('floatingProgressFill');
            
            fillEl.style.width = `${percent}%`;
            textEl.innerHTML = `<span class="floating-progress-spinner"></span>${text}`;
            
            debugLog(`ðŸ“Š Progress: ${percent}% - ${text}`);
        }

        function hideFloatingProgress() {
            const floatingProgress = document.getElementById('floatingProgress');
            floatingProgress.classList.remove('active');
            debugLog(`âœ… Floating progress hidden`);
        }

        // Utility function to yield to UI thread
        function yieldToUI() {
            return new Promise(resolve => setTimeout(resolve, 10));
        }

        // OPTIMIZED: Handle save end response with fast BPM extraction and delayed processing
        async function handleSaveEnd(macroNum, status) {
            if (!currentTransfer.active || currentTransfer.loopNum !== macroNum) {
                return;
            }
            
            debugLog(`ðŸ Save transfer completed: ${currentTransfer.receivedData.length} bytes`);
            
            const loopData = new Uint8Array(currentTransfer.receivedData);
            
            try {
                // Check save format
                const saveFormat = document.getElementById('saveFormat').value;
                
                if (saveFormat === 'loop') {
                    // Native .loop format - fast and simple
                    if (pendingSaveAll) {
                        // Store data for later combination
                        const quickBPM = extractBPMQuickly(loopData);
                        saveAllLoopsData[macroNum] = { data: loopData, bpm: quickBPM };
                        debugLog(`ðŸ’¾ Stored loop ${macroNum} data for .loop export (BPM: ${quickBPM})`);
                    } else {
                        // Individual save as .loop
                        const quickBPM = extractBPMQuickly(loopData);
                        debugLog(`âš¡ Quick BPM extraction: ${quickBPM} BPM`);
                        
                        const chosenPath = await showSaveDialogNative(`loop${macroNum}`, quickBPM, 'loop');
                        if (!chosenPath) {
                            document.getElementById('saveStatus').classList.remove('active');
                            return;
                        }
                        
                        showFloatingProgress(`Saving ${extractFilename(chosenPath)}`, "Writing .loop file...");
                        await yieldToUI();
                        
                        await saveLoopFileNative(chosenPath, loopData, quickBPM, macroNum);
                        
                        updateFloatingProgress(100, "Complete!");
                        setTimeout(() => {
                            hideFloatingProgress();
                            showStatus(`Saved ${extractFilename(chosenPath)}`, 'success');
                        }, 500);
                        
                        document.getElementById('saveStatus').classList.remove('active');
                    }
                } else {
                    // MIDI format - original slow conversion
                    if (pendingSaveAll) {
                        // Store data for later combination - OPTIMIZED: just extract BPM quickly
                        const quickBPM = extractBPMQuickly(loopData);
                        saveAllLoopsData[macroNum] = { data: loopData, bpm: quickBPM };
                        debugLog(`ðŸ’¾ Stored loop ${macroNum} data for MIDI export (BPM: ${quickBPM})`);
                    } else {
                        // Individual save - OPTIMIZED: Show save dialog immediately after quick BPM extraction
                        const quickBPM = extractBPMQuickly(loopData);
                        debugLog(`âš¡ Quick BPM extraction: ${quickBPM} BPM`);
                        
                        // Show save dialog IMMEDIATELY (performance optimized)
                        const chosenPath = await showSaveDialogWithBPM(`loop${macroNum}`, quickBPM);
                        if (!chosenPath) {
                            // User cancelled
                            document.getElementById('saveStatus').classList.remove('active');
                            return;
                        }
                        
                        // Show floating progress bar IMMEDIATELY and yield to UI
                        showFloatingProgress(`Saving ${extractFilename(chosenPath)}`, "Starting processing...");
                        await yieldToUI(); // Allow UI to update
                    
                    // NOW do the heavy processing AFTER UI has updated
                    debugLog(`ðŸ’¾ Save path confirmed, starting full processing...`);
                    updateFloatingProgress(20, "Parsing MIDI events...");
                    await yieldToUI(); // Allow UI to update
                    
                    const parsedLoop = parseLoopData(loopData);
                    if (parsedLoop) {
                        updateFloatingProgress(50, "Creating MIDI file structure...");
                        await yieldToUI(); // Allow UI to update
                        
                        const bpm = parsedLoop.bpm;
                        
                        // Convert to MIDI using the chosen path
                        const loopsData = {};
                        loopsData[macroNum] = parsedLoop;
                        
                        updateFloatingProgress(75, "Generating MIDI data...");
                        await yieldToUI(); // Allow UI to update
                        
                        const midiData = createMIDIFile(loopsData, chosenPath, bpm);
                        
                        if (midiData) {
                            updateFloatingProgress(90, "Writing file to disk...");
                            await yieldToUI(); // Allow UI to update
                            
                            await saveMIDIFileDirect(chosenPath, midiData);
                            updateFloatingProgress(100, "Complete!");
                            
                            // Brief delay to show completion before hiding
                            setTimeout(() => {
                                hideFloatingProgress();
                                showStatus(`Saved ${extractFilename(chosenPath)}`, 'success');
                            }, 750); // Slightly longer delay to see completion
                        } else {
                            hideFloatingProgress();
                            showStatus('Failed to create MIDI file', 'error');
                        }
                    } else {
                        hideFloatingProgress();
                        showStatus('Failed to parse loop data', 'error');
                    }
                    document.getElementById('saveStatus').classList.remove('active');
                    }
                }
            } catch (error) {
                hideFloatingProgress();
                showStatus(`Save failed: ${error.message}`, 'error');
                debugLog(`âŒ Save error: ${error.message}`);
                if (!pendingSaveAll) {
                    document.getElementById('saveStatus').classList.remove('active');
                }
            }
            
            currentTransfer.active = false;
        }

        // New function to show save dialog with BPM auto-append
        async function showSaveDialogWithBPM(baseName, bpm) {
            // Check if we're in Tauri environment for native save dialog
            if (typeof window.__TAURI__ !== 'undefined') {
                try {
                    debugLog(`ðŸ” Opening save dialog for ${baseName} at ${bpm} BPM...`);
                    
                    const suggestedName = `${baseName}_${bpm}.midi`;
                    
                    const savePath = await window.__TAURI__.dialog.save({
                        title: 'Save MIDI File (BPM will be auto-appended)',
                        defaultPath: defaultSaveFolder ? 
                            await window.__TAURI__.path.join(defaultSaveFolder, suggestedName) : 
                            suggestedName,
                        filters: [{
                            name: 'MIDI Files',
                            extensions: ['mid', 'midi']
                        }]
                    });

                    if (!savePath) {
                        debugLog('â„¹ï¸ User cancelled save dialog');
                        return null; // User cancelled
                    }

                    // Extract folder from chosen save path and update default
                    const saveFolder = await window.__TAURI__.path.dirname(savePath);
                    defaultSaveFolder = saveFolder;
                    debugLog(`ðŸ“ Updated default folder to: ${saveFolder}`);

                    // Extract the base name from what user typed and append BPM
                    let userBaseName = await window.__TAURI__.path.basename(savePath);
                    
                    // Remove .midi/.mid extension if present
                    userBaseName = userBaseName.replace(/\.(midi?|mid)$/i, '');
                    
                    // Check if BPM is already included (avoid double-adding)
                    if (!userBaseName.includes(bpm.toString())) {
                        userBaseName = `${userBaseName}_${bpm}`;
                    }
                    
                    // Reconstruct full path with BPM
                    const finalPath = await window.__TAURI__.path.join(saveFolder, `${userBaseName}.midi`);
                    
                    debugLog(`ðŸ’¾ Final save path: ${finalPath}`);
                    return finalPath;
                    
                } catch (error) {
                    debugLog(`âŒ Tauri save dialog failed: ${error.message}`);
                    showStatus(`Save dialog failed: ${error.message}`, 'error');
                    return null;
                }
            } else {
                // Browser fallback - use a simple prompt
                const userInput = prompt(`Enter filename for MIDI file (${bpm} BPM will be auto-appended):`, baseName);
                if (userInput === null) {
                    return null; // User cancelled
                }
                
                let fileName = userInput.trim();
                if (!fileName) {
                    fileName = baseName;
                }
                
                // Check if BPM is already included
                if (!fileName.includes(bpm.toString())) {
                    fileName = `${fileName}_${bpm}`;
                }
                
                return `${fileName}.midi`;
            }
        }

        // Native save dialog for .loop files
        async function showSaveDialogNative(baseName, bpm, extension) {
            if (typeof window.__TAURI__ !== 'undefined') {
                try {
                    debugLog(`ðŸ” Opening save dialog for ${baseName} at ${bpm} BPM (.${extension})...`);
                    
                    const suggestedName = `${baseName}_${bpm}.${extension}`;
                    
                    const savePath = await window.__TAURI__.dialog.save({
                        title: `Save ${extension.toUpperCase()} File`,
                        defaultPath: defaultSaveFolder ? 
                            await window.__TAURI__.path.join(defaultSaveFolder, suggestedName) : 
                            suggestedName,
                        filters: [{
                            name: `${extension.toUpperCase()} Files`,
                            extensions: [extension]
                        }]
                    });

                    if (!savePath) {
                        debugLog('â„¹ï¸ User cancelled save dialog');
                        return null;
                    }

                    const saveFolder = await window.__TAURI__.path.dirname(savePath);
                    defaultSaveFolder = saveFolder;
                    debugLog(`ðŸ“ Updated default folder to: ${saveFolder}`);

                    let userBaseName = await window.__TAURI__.path.basename(savePath);
                    userBaseName = userBaseName.replace(new RegExp(`\\.${extension}$`, 'i'), '');
                    
                    if (!userBaseName.includes(bpm.toString())) {
                        userBaseName = `${userBaseName}_${bpm}`;
                    }
                    
                    const finalPath = await window.__TAURI__.path.join(saveFolder, `${userBaseName}.${extension}`);
                    debugLog(`ðŸ’¾ Final save path: ${finalPath}`);
                    return finalPath;
                    
                } catch (error) {
                    debugLog(`âŒ Tauri save dialog failed: ${error.message}`);
                    showStatus(`Save dialog failed: ${error.message}`, 'error');
                    return null;
                }
            } else {
                const userInput = prompt(`Enter filename for .${extension} file (${bpm} BPM will be auto-appended):`, baseName);
                if (userInput === null) return null;
                
                let fileName = userInput.trim() || baseName;
                if (!fileName.includes(bpm.toString())) {
                    fileName = `${fileName}_${bpm}`;
                }
                
                return `${fileName}.${extension}`;
            }
        }

		// Save native .loop file format
		async function saveLoopFileNative(filePath, loopData, bpm, loopNum) {
			try {
				// Create .loop file format:
				// Header: "MSWLOOP1" (8 bytes)
				// BPM: uint32 (4 bytes)
				// Loop number: uint8 (1 byte)
				// Data length: uint32 (4 bytes)
				// Data: raw loop data (variable length)
				
				const header = new TextEncoder().encode('MSWLOOP1');
				const headerArray = new Uint8Array(17 + loopData.length);
				
				// Write header
				headerArray.set(header, 0);
				
				// Write BPM (little endian)
				const bpmValue = bpm || 120;
				headerArray[8] = bpmValue & 0xFF;
				headerArray[9] = (bpmValue >> 8) & 0xFF;
				headerArray[10] = (bpmValue >> 16) & 0xFF;
				headerArray[11] = (bpmValue >> 24) & 0xFF;
				
				// Write loop number
				headerArray[12] = loopNum;
				
				// Write data length (little endian)
				headerArray[13] = loopData.length & 0xFF;
				headerArray[14] = (loopData.length >> 8) & 0xFF;
				headerArray[15] = (loopData.length >> 16) & 0xFF;
				headerArray[16] = (loopData.length >> 24) & 0xFF;
				
				// Write loop data
				headerArray.set(loopData, 17);
				
				if (typeof window.__TAURI__ !== 'undefined') {
					// Use writeFile (not writeBinaryFile)
					await window.__TAURI__.fs.writeFile(filePath, headerArray);
					debugLog(`âœ… Saved .loop file: ${filePath}`);
				} else {
					// Browser fallback - download file
					const blob = new Blob([headerArray], { type: 'application/octet-stream' });
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = filePath;
					a.click();
					URL.revokeObjectURL(url);
					debugLog(`âœ… Downloaded .loop file: ${filePath}`);
				}
			} catch (error) {
				debugLog(`âŒ Failed to save .loop file: ${error.message}`);
				throw error;
			}
		}

        // Request save from device (individual loop)
        async function requestSaveLoop(loopNum) {
            currentTransfer = {
                active: true,
                isLoading: false,
                loopNum: loopNum,
                expectedPackets: 0,
                receivedPackets: 0,
                totalSize: 0,
                receivedData: [],
                fileName: `loop${loopNum}.midi`
            };

            if (!(await ensureConnection())) {
                return;
            }
            
            try {
                debugLog(`ðŸŽ¯ Requesting save of loop ${loopNum}`);
                await sendHIDPacket(HID_CMD_REQUEST_SAVE, loopNum, 0);
            } catch (error) {
                showStatus(`Save request failed: ${error.message}`, 'error');
            }
        }

        // Request all loops for save all operation
        async function requestAllLoops() {
            debugLog('ðŸŽ¯ Starting save all loops operation');
            document.getElementById('saveStatus').classList.add('active');
            updateSaveProgress(0);

            // Request each loop individually
            for (let i = 1; i <= 4; i++) {
                currentTransfer = {
                    active: true,
                    isLoading: false,
                    loopNum: i,
                    expectedPackets: 0,
                    receivedPackets: 0,
                    totalSize: 0,
                    receivedData: [],
                    fileName: `${saveAllName}_loop${i}.midi`
                };

                try {
                    await sendHIDPacket(HID_CMD_REQUEST_SAVE, i, 0);
                    // Wait for this loop to complete before requesting next
                    await waitForCurrentTransfer();
                } catch (error) {
                    debugLog(`âŒ Failed to save loop ${i}: ${error.message}`);
                }
            }

            // After all individual loops are saved, create the combined MIDI file
            if (pendingSaveAll) {
                await createCombinedMIDIFile();
                pendingSaveAll = false;
                document.getElementById('saveStatus').classList.remove('active');
                
                // Count how many loops were actually saved
                const savedCount = Object.keys(saveAllLoopsData).length;
                showStatus(`MIDI file created with ${savedCount} loops!`, 'success');
                debugLog(`ðŸŽ‰ Save all operation completed: ${savedCount} loops in MIDI file`);
                
                // Reset for next operation
                saveAllLoopsData = {};
                saveAllName = '';
            }
        }

        // Wait for current transfer to complete
        function waitForCurrentTransfer() {
            return new Promise((resolve) => {
                const checkComplete = () => {
                    if (!currentTransfer.active) {
                        resolve();
                    } else {
                        setTimeout(checkComplete, 100);
                    }
                };
                checkComplete();
            });
        }

		// OPTIMIZED: Modified createCombinedMIDIFile function for save-all
		async function createCombinedMIDIFile() {
			// Check save format
			const saveFormat = document.getElementById('saveFormat').value;
			
			// Extract BPM from first available loop using quick method
			let masterBPM = 120; // Default
			const firstLoopData = Object.values(saveAllLoopsData)[0];
			if (firstLoopData && firstLoopData.bpm) {
				masterBPM = firstLoopData.bpm;
			}
			
			if (saveFormat === 'loop') {
				// NEW: Save all loops as a SINGLE combined .loop file
				const loopCount = Object.keys(saveAllLoopsData).length;
				
				// Show save dialog once for the combined file
				const chosenPath = await showSaveDialogNative('all_loops', masterBPM, 'loop');
				if (!chosenPath) {
					showStatus('Save cancelled by user', 'error');
					return;
				}
				
				showFloatingProgress(`Saving ${extractFilename(chosenPath)}`, `Combining ${loopCount} loops...`);
				await yieldToUI();
				
				try {
					// Create combined .loop file
					await saveCombinedLoopFile(chosenPath, saveAllLoopsData, masterBPM);
					
					updateFloatingProgress(100, "Complete!");
					setTimeout(() => {
						hideFloatingProgress();
						showStatus(`Saved combined .loop file with ${loopCount} loops!`, 'success');
					}, 750);
				} catch (error) {
					hideFloatingProgress();
					showStatus(`Failed to save .loop file: ${error.message}`, 'error');
					debugLog(`âŒ Failed to save combined .loop file: ${error.message}`);
				}
				
				return;
			}
            
            // Original MIDI file handling
            // Show save dialog IMMEDIATELY using quick BPM
            const chosenPath = await showSaveDialogWithBPM(saveAllName, masterBPM);
            if (!chosenPath) {
                // User cancelled
                showStatus('Save cancelled by user', 'error');
                return;
            }
            
            // Show floating progress bar IMMEDIATELY and yield to UI
            const loopCount = Object.keys(saveAllLoopsData).length;
            showFloatingProgress(`Saving ${extractFilename(chosenPath)}`, `Starting processing...`);
            await yieldToUI(); // Allow UI to update
            
            // NOW do the heavy processing AFTER save dialog
            debugLog(`ðŸ’¾ Save path confirmed, starting full processing of ${loopCount} loops...`);
            
            const parsedLoops = {};
            let processedCount = 0;
            const totalLoops = Object.keys(saveAllLoopsData).length;
            
            // Parse all collected loop data (the heavy operation happens here)
            for (const [loopNum, loopInfo] of Object.entries(saveAllLoopsData)) {
                updateFloatingProgress(
                    (processedCount / totalLoops) * 60, // Use 60% for parsing phase
                    `Parsing loop ${loopNum} (${processedCount + 1}/${totalLoops})...`
                );
                await yieldToUI(); // Allow UI to update between loops
                
                const parsedLoop = parseLoopData(loopInfo.data);
                if (parsedLoop) {
                    parsedLoops[loopNum] = parsedLoop;
                    if (parsedLoop.bpm && parsedLoop.bpm !== 120) {
                        masterBPM = parsedLoop.bpm; // Use BPM from first non-default loop
                    }
                }
                processedCount++;
            }
            
            updateFloatingProgress(70, "Creating MIDI file structure...");
            await yieldToUI(); // Allow UI to update
            
            const midiData = createMIDIFile(parsedLoops, chosenPath, masterBPM);
            
            if (midiData && midiData.length > 0) {
                updateFloatingProgress(90, "Writing file to disk...");
                await yieldToUI(); // Allow UI to update
                
                await saveMIDIFileDirect(chosenPath, midiData);
                updateFloatingProgress(100, "Complete!");
                
                debugLog(`ðŸ’¾ Created combined MIDI file: ${chosenPath}`);
                
                // Brief delay to show completion before hiding
                setTimeout(() => {
                    hideFloatingProgress();
                    showStatus(`Saved combined MIDI file: ${extractFilename(chosenPath)}`, 'success');
                }, 750); // Slightly longer delay to see completion
            } else {
                hideFloatingProgress();
                debugLog(`âŒ Failed to create combined MIDI file`);
                showStatus(`Failed to create MIDI file`, 'error');
            }
        }
		
		// Save combined .loop file format (multiple loops in one file)
		async function saveCombinedLoopFile(filePath, loopsData, bpm) {
			try {
				const loopNumbers = Object.keys(loopsData).map(n => parseInt(n)).sort();
				const loopCount = loopNumbers.length;
				
				debugLog(`ðŸ“„ Creating combined .loop file with ${loopCount} loops`);
				
				// Calculate total size needed
				let totalSize = 16; // Header (8) + Version (1) + Count (1) + Global BPM (4) + Reserved (2)
				loopNumbers.forEach(loopNum => {
					const loopInfo = loopsData[loopNum];
					totalSize += 1 + 4 + 4 + loopInfo.data.length; // Loop# + BPM + Length + Data
				});
				
				// Create combined file buffer
				const combinedData = new Uint8Array(totalSize);
				let offset = 0;
				
				// Write header "MSWLOOPS" (note the 'S' for multiple loops)
				const header = new TextEncoder().encode('MSWLOOPS');
				combinedData.set(header, offset);
				offset += 8;
				
				// Write version
				combinedData[offset++] = 1;
				
				// Write loop count
				combinedData[offset++] = loopCount;
				
				// Write global BPM (little endian)
				const bpmValue = bpm || 120;
				combinedData[offset++] = bpmValue & 0xFF;
				combinedData[offset++] = (bpmValue >> 8) & 0xFF;
				combinedData[offset++] = (bpmValue >> 16) & 0xFF;
				combinedData[offset++] = (bpmValue >> 24) & 0xFF;
				
				// Write reserved bytes (2 bytes for alignment)
				combinedData[offset++] = 0;
				combinedData[offset++] = 0;
				
				debugLog(`ðŸ“„ Combined .loop header: ${offset} bytes`);
				
				// Write each loop's data
				loopNumbers.forEach(loopNum => {
					const loopInfo = loopsData[loopNum];
					const loopData = loopInfo.data;
					const loopBPM = loopInfo.bpm || bpm || 120;
					
					debugLog(`ðŸ“„ Adding loop ${loopNum}: ${loopData.length} bytes at BPM ${loopBPM}`);
					
					// Write loop number
					combinedData[offset++] = loopNum;
					
					// Write loop-specific BPM (little endian)
					combinedData[offset++] = loopBPM & 0xFF;
					combinedData[offset++] = (loopBPM >> 8) & 0xFF;
					combinedData[offset++] = (loopBPM >> 16) & 0xFF;
					combinedData[offset++] = (loopBPM >> 24) & 0xFF;
					
					// Write data length (little endian)
					combinedData[offset++] = loopData.length & 0xFF;
					combinedData[offset++] = (loopData.length >> 8) & 0xFF;
					combinedData[offset++] = (loopData.length >> 16) & 0xFF;
					combinedData[offset++] = (loopData.length >> 24) & 0xFF;
					
					// Write loop data
					combinedData.set(loopData, offset);
					offset += loopData.length;
				});
				
				debugLog(`ðŸ“„ Total combined .loop file size: ${offset} bytes`);
				
				// Save the file
				if (typeof window.__TAURI__ !== 'undefined') {
					// Use writeFile (not writeBinaryFile) - same as MIDI files
					await window.__TAURI__.fs.writeFile(filePath, combinedData);
					debugLog(`âœ… Saved combined .loop file: ${filePath}`);
				} else {
					// Browser fallback - download file
					const blob = new Blob([combinedData], { type: 'application/octet-stream' });
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = filePath;
					a.click();
					URL.revokeObjectURL(url);
					debugLog(`âœ… Downloaded combined .loop file: ${filePath}`);
				}
			} catch (error) {
				debugLog(`âŒ Failed to save combined .loop file: ${error.message}`);
				throw error;
			}
		}

        // New function to save directly to a specific path (no dialog)
        async function saveMIDIFileDirect(filePath, data) {
            // Check if we're in Tauri environment
            if (typeof window.__TAURI__ !== 'undefined') {
                try {
                    await window.__TAURI__.fs.writeFile(filePath, data);
                    debugLog(`ðŸ’¾ Saved MIDI file: ${filePath} (${data.length} bytes)`);
                    return;
                } catch (error) {
                    debugLog(`âŒ Tauri save failed: ${error.message}`);
                    throw error;
                }
            } else {
                // Browser download fallback
                debugLog('ðŸ’¾ Saving MIDI file using browser download...');
                const blob = new Blob([data], { type: 'audio/midi' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = extractFilename(filePath);
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                debugLog(`ðŸ’¾ Downloaded: ${extractFilename(filePath)} (${data.length} bytes)`);
            }
        }

        // Helper function to extract filename from path
        function extractFilename(filePath) {
            if (typeof window.__TAURI__ !== 'undefined') {
                // Use Tauri path utilities if available
                return filePath.split(/[/\\]/).pop();
            } else {
                return filePath;
            }
        }

        // NEW: Direct save all function (no popup modal)
        async function saveAllLoopsDirectly() {
            if (!(await ensureConnection())) {
                return;
            }

            // Reset save all state
            saveAllLoopsData = {};
            pendingSaveAll = true;
            saveAllName = "loops"; // Default base name
            
            // Start by requesting all individual loops
            requestAllLoops();
        }

        // Browse for MIDI files
        // Parse .loop file format
		// Parse .loop file format (both single and combined)
		function parseLoopFile(data) {
			try {
				// Check header
				const header = new TextDecoder().decode(data.slice(0, 8));
				
				if (header === 'MSWLOOP1') {
					// Single loop file format
					const bpm = data[8] | (data[9] << 8) | (data[10] << 16) | (data[11] << 24);
					const loopNum = data[12];
					const dataLength = data[13] | (data[14] << 8) | (data[15] << 16) | (data[16] << 24);
					const loopData = data.slice(17, 17 + dataLength);
					
					debugLog(`ðŸ“„ Parsed single .loop file: Loop ${loopNum}, BPM ${bpm}, ${dataLength} bytes`);
					
					return {
						bpm: bpm,
						loopNum: loopNum,
						loopData: loopData,
						isCombined: false
					};
				} else if (header === 'MSWLOOPS') {
					// Combined loops file format
					const version = data[8];
					const loopCount = data[9];
					const globalBPM = data[10] | (data[11] << 8) | (data[12] << 16) | (data[13] << 24);
					
					debugLog(`ðŸ“„ Parsed combined .loop file: ${loopCount} loops, Global BPM ${globalBPM}`);
					
					let offset = 16; // Skip header
					const loops = [];
					
					for (let i = 0; i < loopCount; i++) {
						const loopNum = data[offset++];
						const loopBPM = data[offset] | (data[offset+1] << 8) | (data[offset+2] << 16) | (data[offset+3] << 24);
						offset += 4;
						const dataLength = data[offset] | (data[offset+1] << 8) | (data[offset+2] << 16) | (data[offset+3] << 24);
						offset += 4;
						const loopData = data.slice(offset, offset + dataLength);
						offset += dataLength;
						
						loops.push({
							loopNum: loopNum,
							bpm: loopBPM,
							loopData: loopData
						});
						
						debugLog(`ðŸ“„   Loop ${loopNum}: BPM ${loopBPM}, ${dataLength} bytes`);
					}
					
					return {
						bpm: globalBPM,
						isCombined: true,
						loops: loops
					};
				} else {
					throw new Error('Invalid .loop file header');
				}
			} catch (error) {
				debugLog(`âŒ Failed to parse .loop file: ${error.message}`);
				return null;
			}
		}

        async function browseFiles() {
            try {
                debugLog('ðŸ” Opening file browser for MIDI and .loop files...');
                
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.mid,.midi,.loop';
                input.multiple = true;
                
                input.onchange = async (e) => {
                    const files = Array.from(e.target.files);
                    
                    // Clear existing files
                    loadedFiles = [];
                    
                    for (const file of files) {
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            const data = new Uint8Array(arrayBuffer);
                            
                            // Check if it's a .loop file
							// Check if it's a .loop file
							if (file.name.toLowerCase().endsWith('.loop')) {
								// Parse .loop file
								const loopInfo = parseLoopFile(data);
								
								if (loopInfo) {
									if (loopInfo.isCombined) {
										// Combined file - create tracks for each loop
										const tracks = [];
										loopInfo.loops.forEach(loop => {
											tracks.push({
												name: `Loop ${loop.loopNum}`,
												events: []
											});
										});
										
										loadedFiles.push({
											name: file.name,
											data: data,
											date: new Date(file.lastModified),
											size: file.size,
											tracks: tracks,
											bpm: loopInfo.bpm,
											isLoopFile: true,
											isCombinedLoop: true,
											loopData: loopInfo.loops // Store all loops
										});
										
										debugLog(`âœ… Loaded combined .loop file: ${file.name} (${loopInfo.loops.length} loops, ${loopInfo.bpm} BPM)`);
									} else {
										// Single loop file
										loadedFiles.push({
											name: file.name,
											data: data,
											date: new Date(file.lastModified),
											size: file.size,
											tracks: [{
												name: `Loop ${loopInfo.loopNum}`,
												events: []
											}],
											bpm: loopInfo.bpm,
											isLoopFile: true,
											isCombinedLoop: false,
											loopData: loopInfo.loopData,
											loopNum: loopInfo.loopNum
										});
										
										debugLog(`âœ… Loaded single .loop file: ${file.name} (Loop ${loopInfo.loopNum}, ${loopInfo.bpm} BPM)`);
									}
								} else {
									throw new Error('Invalid .loop file format');
								}
							} else {
                                // Parse MIDI file
                                const { tracks, bpm: detectedBPM } = parseMIDIFile(data);
                                
                                // Try to extract BPM from filename
                                const filenameBPM = extractBPMFromFilename(file.name);
                                const finalBPM = filenameBPM || detectedBPM;
                                
                                loadedFiles.push({
                                    name: file.name,
                                    data: data,
                                    date: new Date(file.lastModified),
                                    size: file.size,
                                    tracks: tracks,
                                    bpm: finalBPM,
                                    isLoopFile: false
                                });
                                
                                debugLog(`âœ… Loaded MIDI file: ${file.name} (${tracks.length} tracks, ${finalBPM} BPM)`);
                            }
                        } catch (error) {
                            debugLog(`âŒ Failed to parse file ${file.name}: ${error.message}`);
                            showStatus(`Failed to parse ${file.name}: ${error.message}`, 'error');
                        }
                    }
                    
                    updateFileList();
                    showStatus(`Loaded ${loadedFiles.length} files`, 'success');
                    
                    // Auto-select first file and check for advanced assignment
                    if (loadedFiles.length > 0) {
                        selectedFile = 0;
                        updateFileList(); // Update to show selection
                        
                        // Check if we should auto-enable advanced assignment for the selected file
                        if (!loadedFiles[0].isLoopFile && checkAutoEnableAdvanced(loadedFiles[0])) {
                            autoEnableAdvanced();
                        }
                    }
                };
                
                input.click();
            } catch (error) {
                showStatus('Error loading files', 'error');
                debugLog(`âŒ File browser failed: ${error.message}`);
            }
        }

        // Check if tracks have intelligent naming patterns
        function hasIntelligentNaming(tracks) {
            let intelligentTracks = 0;
            tracks.forEach(track => {
                if (parseTrackName(track.name)) {
                    intelligentTracks++;
                }
            });
            return intelligentTracks > 0;
        }

        // Check if we should auto-enable advanced assignment
        function checkAutoEnableAdvanced(file) {
            if (!file || !file.tracks) return false;
            
            // Auto-enable if 5+ tracks AND no intelligent naming
            if (file.tracks.length >= 5 && !hasIntelligentNaming(file.tracks)) {
                debugLog(`ðŸŽ¯ Auto-enabling advanced assignment: ${file.tracks.length} tracks with no intelligent naming`);
                return true;
            }
            
            return false;
        }

        // Auto-enable advanced track assignment
        function autoEnableAdvanced() {
            const checkbox = document.getElementById('showAdvanced');
            const advancedSection = document.getElementById('advancedTrackSection');
            
            if (!checkbox.checked) {
                checkbox.checked = true;
                advancedSection.classList.add('visible');
                updateTrackSelection();
                updateAssignmentButtonLabels();
                
                const selectedFileObj = loadedFiles[selectedFile];
                showStatus(`Advanced Track Assignment required: ${selectedFileObj.tracks.length} tracks need manual assignment. "Load All Tracks" disabled.`, 'success');
                debugLog(`âœ… Auto-enabled advanced track assignment for ${selectedFileObj.tracks.length} tracks - Load All disabled`);
            }
        }
        
        function parseTrackName(trackName) {
            if (!trackName) return null;
            
            // Look for patterns like "Loop 1 Main", "Loop 2 Overdub", etc.
            const mainMatch = trackName.match(/Loop\s+(\d+)\s+Main/i);
            if (mainMatch) {
                const loopNum = parseInt(mainMatch[1]);
                if (loopNum >= 1 && loopNum <= 4) {
                    return { loopNum, isOverdub: false };
                }
            }
            
            const overdubMatch = trackName.match(/Loop\s+(\d+)\s+Overdub/i);
            if (overdubMatch) {
                const loopNum = parseInt(overdubMatch[1]);
                if (loopNum >= 1 && loopNum <= 4) {
                    return { loopNum, isOverdub: true };
                }
            }
            
            return null; // No pattern match
        }

        // Enhanced loadAllLoopsToDevice function with intelligent assignment
        async function loadAllLoopsToDevice() {
            if (selectedFile === null || !loadedFiles[selectedFile]) {
                showStatus('Please select a file first', 'error');
                return;
            }
            
            if (!(await ensureConnection())) {
                return;
            }
            
            const selectedFileObj = loadedFiles[selectedFile];
            
		// Check if this is a .loop file
		if (selectedFileObj.isLoopFile) {
			if (selectedFileObj.isCombinedLoop) {
				// Combined .loop file - load all loops
				debugLog(`ðŸ“¤ Loading combined .loop file ${selectedFileObj.name} to device`);
				
				try {
					document.getElementById('loadStatus').classList.add('active');
					
					const totalLoops = selectedFileObj.loopData.length;
					let loadedCount = 0;
					
					for (const loop of selectedFileObj.loopData) {
						updateLoadProgress(((loadedCount + 0.5) / totalLoops) * 100);
						await loadLoopData(loop.loopData, loop.loopNum);
						loadedCount++;
						updateLoadProgress((loadedCount / totalLoops) * 100);
						
						// Update current loop contents tracking
						currentLoopContents[loop.loopNum] = {
							length: 0,
							name: `${selectedFileObj.name} - Loop ${loop.loopNum}`,
							displayName: `Loop ${loop.loopNum}`,
							title: `${selectedFileObj.name} - Loop ${loop.loopNum}`
						};
						
						debugLog(`âœ… Loaded loop ${loop.loopNum} from combined file`);
					}
					
					document.getElementById('loadStatus').classList.remove('active');
					showStatus(`Successfully loaded ${totalLoops} loops from ${selectedFileObj.name}!`, 'success');
					
				} catch (error) {
					document.getElementById('loadStatus').classList.remove('active');
					showStatus(`Load failed: ${error.message}`, 'error');
					debugLog(`âŒ Combined .loop file load failed: ${error.message}`);
				}
				
				return;
			} else {
				// Single .loop file
				debugLog(`ðŸ“¤ Loading single .loop file ${selectedFileObj.name} to device`);
				
				try {
					document.getElementById('loadStatus').classList.add('active');
					updateLoadProgress(50);
					
					// Directly load the loop data to the device
					await loadLoopData(selectedFileObj.loopData, selectedFileObj.loopNum);
					
					updateLoadProgress(100);
					document.getElementById('loadStatus').classList.remove('active');
					
					showStatus(`Successfully loaded ${selectedFileObj.name} to Loop ${selectedFileObj.loopNum}!`, 'success');
					debugLog(`âœ… .loop file loaded to Loop ${selectedFileObj.loopNum}`);
					
					// Update current loop contents tracking
					currentLoopContents[selectedFileObj.loopNum] = {
						length: 0,  // Unknown from .loop file
						name: selectedFileObj.name,
						displayName: selectedFileObj.name,
						title: selectedFileObj.name
					};
					
				} catch (error) {
					document.getElementById('loadStatus').classList.remove('active');
					showStatus(`Load failed: ${error.message}`, 'error');
					debugLog(`âŒ .loop file load failed: ${error.message}`);
				}
				
				return;
			}
		}
            
            // Original MIDI file handling
            debugLog(`ðŸ“¤ Loading all tracks from ${selectedFileObj.name}`);
            
            try {
                document.getElementById('loadStatus').classList.add('active');
                updateLoadProgress(0);
                
                // Step 1: Categorize tracks by their intended assignments
                const assignedTracks = new Map(); // loopNum -> { main: track, overdub: track }
                const unassignedTracks = [];
                let intelligentAssignments = 0;
                
                selectedFileObj.tracks.forEach((track, trackIndex) => {
                    const assignment = parseTrackName(track.name);
                    if (assignment) {
                        // Track has a recognizable name pattern
                        if (!assignedTracks.has(assignment.loopNum)) {
                            assignedTracks.set(assignment.loopNum, { main: null, overdub: null });
                        }
                        
                        const loopAssignment = assignedTracks.get(assignment.loopNum);
                        if (assignment.isOverdub) {
                            loopAssignment.overdub = { track, trackIndex };
                        } else {
                            loopAssignment.main = { track, trackIndex };
                        }
                        
                        intelligentAssignments++;
                        debugLog(`ðŸ“¤ Intelligent assignment: "${track.name}" â†’ Loop ${assignment.loopNum} ${assignment.isOverdub ? 'Overdub' : 'Main'}`);
                    } else {
                        // Track doesn't match pattern, will be assigned sequentially
                        unassignedTracks.push({ track, trackIndex });
                        debugLog(`ðŸ“¤ Sequential assignment: "${track.name}" (no pattern match)`);
                    }
                });
                
                // Find shortest track for quantization reference
                const allTracks = selectedFileObj.tracks;
                const shortestTrackIndex = findShortestTrackIndex(allTracks, selectedFileObj.bpm);
                
                let loadedCount = 0;
                let totalOperations = 0;
                
                // Count total operations for progress tracking
                assignedTracks.forEach(loopData => {
                    if (loopData.main) totalOperations++;
                    if (loopData.overdub) totalOperations++;
                });
                totalOperations += Math.min(unassignedTracks.length, 4); // Max 4 sequential assignments
                
                if (intelligentAssignments > 0) {
                    showStatus(`Using intelligent assignment for ${intelligentAssignments} tracks...`, 'success');
                }
                
                // Step 2: Load tracks with intelligent assignments
                for (const [loopNum, loopData] of assignedTracks) {
                    // Load main track first
                    if (loopData.main) {
                        const { track, trackIndex } = loopData.main;
                        const skipQuantization = trackIndex === shortestTrackIndex;
                        await loadSingleTrackToLoop(track, trackIndex, loopNum, false, selectedFileObj.bpm, skipQuantization);
                        loadedCount++;
                        updateLoadProgress((loadedCount / totalOperations) * 100);
                        debugLog(`ðŸ“¤ Loaded main track "${track.name}" to loop ${loopNum}`);
                    }
                    
                    // Then load overdub track if it exists
                    if (loopData.overdub) {
                        const { track, trackIndex } = loopData.overdub;
                        const skipQuantization = trackIndex === shortestTrackIndex;
                        await loadSingleTrackToLoop(track, trackIndex, loopNum, true, selectedFileObj.bpm, skipQuantization);
                        loadedCount++;
                        updateLoadProgress((loadedCount / totalOperations) * 100);
                        debugLog(`ðŸ“¤ Loaded overdub track "${track.name}" to loop ${loopNum}`);
                    }
                }
                
                // Step 3: Load remaining unassigned tracks sequentially to available slots
                let nextAvailableLoop = 1;
                for (const { track, trackIndex } of unassignedTracks) {
                    // Find next available main loop slot
                    while (nextAvailableLoop <= 4) {
                        const loopData = assignedTracks.get(nextAvailableLoop);
                        if (!loopData || !loopData.main) {
                            // This loop slot is available
                            break;
                        }
                        nextAvailableLoop++;
                    }
                    
                    if (nextAvailableLoop > 4) {
                        debugLog(`âš ï¸ No more available loop slots for track "${track.name}"`);
                        break;
                    }
                    
                    const skipQuantization = trackIndex === shortestTrackIndex;
                    await loadSingleTrackToLoop(track, trackIndex, nextAvailableLoop, false, selectedFileObj.bpm, skipQuantization);
                    loadedCount++;
                    updateLoadProgress((loadedCount / totalOperations) * 100);
                    debugLog(`ðŸ“¤ Loaded sequential track "${track.name}" to loop ${nextAvailableLoop}`);
                    
                    nextAvailableLoop++;
                }
                
                // Update button labels after all tracks are loaded
                updateAssignmentButtonLabels();
                
                document.getElementById('loadStatus').classList.remove('active');
                
                if (intelligentAssignments > 0) {
                    showStatus(`Successfully loaded ${loadedCount} tracks (${intelligentAssignments} intelligent, ${loadedCount - intelligentAssignments} sequential)!`, 'success');
                } else {
                    showStatus(`Successfully loaded ${loadedCount} tracks to device!`, 'success');
                }
                debugLog(`âœ… Load all complete - ${loadedCount} tracks loaded (${intelligentAssignments} intelligent assignments)`);
                
            } catch (error) {
                document.getElementById('loadStatus').classList.remove('active');
                showStatus(`Load failed: ${error.message}`, 'error');
                debugLog(`âŒ Load all failed: ${error.message}`);
            }
        }

		// Helper function to load a single track to a specific loop
		async function loadSingleTrackToLoop(track, trackIndex, loopNum, isOverdub, bpm, skipQuantization = false) {
			debugLog(`ðŸ“¤ Loading track "${track.name}" to Loop ${loopNum} (${isOverdub ? 'overdub' : 'main'})`);
			
			// Convert MIDI events to loop format
			const events = convertMIDIToLoopFormat(track.events, bpm, MIDI_TPQN);
			
			if (events.length > 0) {
				// Calculate timing for this track
				const timing = calculateLoopTiming(events, bpm, track.maxTicks, skipQuantization);
				
				// Create loop data with proper timing
				const loopData = createLoopDataFromEvents(events, loopNum, bpm, timing, isOverdub);
				
				// Send to device using appropriate method
				if (isOverdub) {
					await loadOverdubData(loopData, loopNum);
					debugLog(`ðŸ“¤ Sent overdub data to device (${loopData.length} bytes)`);
				} else {
					await loadLoopData(loopData, loopNum);
					debugLog(`ðŸ“¤ Sent main loop data to device (${loopData.length} bytes)`);
				}
				
				// Update current loop contents tracking
				const trackNumber = trackIndex + 1;
				const trackTitle = track.name || `Untitled Track`;
				const trackInfo = {
					length: timing.loopLength,
					name: track.name,
					displayName: `Track ${trackNumber}`,
					title: trackTitle
				};
				
				if (isOverdub) {
					currentOverdubContents[loopNum] = trackInfo;
				} else {
					currentLoopContents[loopNum] = trackInfo;
				}
				
				// Small delay between operations
				await new Promise(resolve => setTimeout(resolve, 100));
			} else {
				debugLog(`âš ï¸ Track "${track.name}" has no events, skipping`);
			}
		}

        // Pre-calculate track timings to find the shortest one
        function findShortestTrackIndex(tracks, bpm) {
            let shortestIndex = -1;
            let shortestLength = Infinity;
            
            tracks.forEach((track, index) => {
                if (track.events && track.events.length > 0) {
                    // Calculate raw timing (no quantization) to find true shortest
                    const events = convertMIDIToLoopFormat(track.events, bpm, MIDI_TPQN);
                    const rawTiming = calculateLoopTiming(events, bpm, track.maxTicks, true); // Skip quantization for comparison
                    
                    if (rawTiming.loopLength < shortestLength) {
                        shortestLength = rawTiming.loopLength;
                        shortestIndex = index;
                    }
                }
            });
            
            if (shortestIndex >= 0) {
                debugLog(`ðŸŽ¯ Shortest track detected: "${tracks[shortestIndex].name}" (${shortestLength}ms) - will skip quantization`);
            }
            
            return shortestIndex;
        }

        // Load loop data to device via HID
        async function loadLoopData(data, loopNum) {
            const totalPackets = Math.ceil(data.length / HID_CHUNK_SIZE);
            
            // Send start packet
            const startData = new Uint8Array(4);
            startData[0] = totalPackets & 0xFF;
            startData[1] = (totalPackets >> 8) & 0xFF;
            startData[2] = data.length & 0xFF;
            startData[3] = (data.length >> 8) & 0xFF;
            
            await sendHIDPacket(HID_CMD_LOAD_START, loopNum, 0, startData);
            
            // Send data packets
            for (let packet = 0; packet < totalPackets; packet++) {
                const offset = packet * HID_CHUNK_SIZE;
                const chunkLen = Math.min(HID_CHUNK_SIZE, data.length - offset);
                const chunkData = data.subarray(offset, offset + chunkLen);
                
                const packetData = new Uint8Array(4 + chunkLen);
                packetData[0] = packet & 0xFF;
                packetData[1] = (packet >> 8) & 0xFF;
                packetData[2] = chunkLen & 0xFF;
                packetData[3] = (chunkLen >> 8) & 0xFF;
                packetData.set(chunkData, 4);
                
                await sendHIDPacket(HID_CMD_LOAD_CHUNK, loopNum, 0, packetData);
                
                // Small delay between packets
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            // Send end packet
            await sendHIDPacket(HID_CMD_LOAD_END, loopNum, 0);
            
            // Wait a bit for the device to process
            await new Promise(resolve => setTimeout(resolve, 50));
        }

        // Update file list (simplified, no more hover popup)
        function updateFileList() {
            const fileList = document.getElementById('fileList');
            
            if (loadedFiles.length === 0) {
                fileList.innerHTML = '<div style="padding: 20px; text-align: center; color: #718096;">No files loaded</div>';
                selectedFile = null;
                updateButtonStates();
                updateTrackSelection(); // Update track selection area
                return;
            }
            
            let html = '';
            loadedFiles.forEach((file, index) => {
                const isSelected = selectedFile === index;
                
                let fileTypeIcon, fileTypeText;
                if (file.isLoopFile) {
                    fileTypeIcon = 'ðŸ”„';
                    fileTypeText = ` (Loop ${file.loopNum}, ${file.bpm} BPM)`;
                } else {
                    fileTypeIcon = 'ðŸŽµ';
                    fileTypeText = ` (${file.tracks.length} tracks, ${file.bpm} BPM)`;
                }
                
                html += `
                    <div class="file-item ${isSelected ? 'selected' : ''}" onclick="selectFile(${index})">
                        <div class="file-info">
                            <div style="font-weight: 500;">${fileTypeIcon} ${file.name}${fileTypeText}</div>
                            <div style="font-size: 0.8rem; color: #718096;">${file.date.toLocaleDateString()}</div>
                        </div>
                        <div class="file-actions">
                            <div style="font-size: 0.8rem; color: #718096;">
                                ${(file.size / 1024).toFixed(1)} KB
                            </div>
                            <button class="file-remove" onclick="removeFile(${index}, event)" title="Remove file">Ã—</button>
                        </div>
                    </div>
                `;
            });
            
            fileList.innerHTML = html;
            updateButtonStates();
            updateTrackSelection(); // Update track selection area
        }

        // Select file
        function selectFile(index) {
            selectedFile = index;
            selectedTrack = null; // Clear track selection when changing files
            clearTrackSelection();
            updateFileList();
            
            // Check if we should auto-enable advanced assignment (only for MIDI files)
            if (loadedFiles[index] && !loadedFiles[index].isLoopFile && checkAutoEnableAdvanced(loadedFiles[index])) {
                autoEnableAdvanced();
            }
        }

        // Remove file from list
        function removeFile(index, event) {
            event.stopPropagation();
            
            const fileName = loadedFiles[index].name;
            
            loadedFiles.splice(index, 1);
            
            if (selectedFile === index) {
                selectedFile = null;
                selectedTrack = null;
            } else if (selectedFile !== null && selectedFile > index) {
                selectedFile--;
            }
            
            clearTrackSelection();
            updateFileList();
            showStatus(`Removed ${fileName}`, 'success');
            debugLog(`ðŸ—‘ï¸ Removed file: ${fileName}`);
        }

        // Update button states based on selected file
        function updateButtonStates() {
            const loadAllBtn = document.getElementById('loadAllBtn');
            
            if (selectedFile === null || !loadedFiles[selectedFile]) {
                // No file selected - disable all buttons
                loadAllBtn.disabled = true;
                loadAllBtn.style.opacity = '0.5';
                loadAllBtn.style.boxShadow = 'none';
                availableTracksInFile = [];
            } else {
                const selectedFileObj = loadedFiles[selectedFile];
                
                // Check if this file should force advanced assignment mode
                const shouldForceAdvanced = checkAutoEnableAdvanced(selectedFileObj);
                
                if (shouldForceAdvanced) {
                    // Disable load all button - force user to use advanced assignment
                    loadAllBtn.disabled = true;
                    loadAllBtn.style.opacity = '0.3';
                    loadAllBtn.style.boxShadow = 'none';
                    loadAllBtn.title = 'Use Advanced Track Assignment for multi-track files';
                } else {
                    // Enable load all button if tracks exist
                    if (selectedFileObj.tracks.length > 0) {
                        loadAllBtn.disabled = false;
                        loadAllBtn.style.opacity = '1';
                        loadAllBtn.style.boxShadow = '0 0 10px rgba(5, 150, 105, 0.5)';
                        loadAllBtn.title = '';
                    } else {
                        loadAllBtn.disabled = true;
                        loadAllBtn.style.opacity = '0.3';
                        loadAllBtn.style.boxShadow = 'none';
                        loadAllBtn.title = '';
                    }
                }
            }
        }

        // Progress bar updates
        function updateSaveProgress(percent) {
            document.getElementById('saveProgress').style.width = percent + '%';
        }

        function updateLoadProgress(percent) {
            document.getElementById('loadProgress').style.width = percent + '%';
        }

        // Auto-connect on page load with retries
        async function autoConnect() {
            let attempts = 0;
            const maxAttempts = 3;
            
            const tryConnect = async () => {
                attempts++;
                debugLog(`ðŸ”„ Auto-connect attempt ${attempts}/${maxAttempts}`);
                
                try {
                    const devices = await navigator.hid.getDevices();
                    
                    if (devices.length > 0) {
                        debugLog(`ðŸ” Found ${devices.length} previously authorized devices`);
                        
                        let selectedDevice = null;
                        
                        for (const device of devices) {
                            debugLog(`  Checking device: ${device.productName || 'Unknown'}`);
                            
                            let hasRawHID = false;
                            device.collections.forEach((collection) => {
                                if (collection.usagePage === 0xFF60 || collection.usagePage === 65376) {
                                    hasRawHID = true;
                                }
                            });
                            
                            if (hasRawHID && !selectedDevice) {
                                selectedDevice = device;
                                break;
                            }
                        }
                        
                        if (!selectedDevice && devices.length > 0) {
                            selectedDevice = devices[0];
                        }
                        
                        if (selectedDevice) {
                            hidDevice = selectedDevice;
                            await hidDevice.open();
                            hidDevice.addEventListener('inputreport', handleHIDInputReport);
                            
                            isConnected = true;
                            updateConnectionStatus();
                            updateDeviceLists(); // Update USB fix box visibility
                            showStatus(`Auto-connected to ${hidDevice.productName || 'MIDIswitch'}`, 'success');
                            debugLog('âœ… Auto-connection successful');
                            return true; // Success
                        }
                    }
                    
                    debugLog('â„¹ï¸ No suitable devices found for auto-connection');
                    return false; // No devices found
                    
                } catch (error) {
                    debugLog(`âš ï¸ Auto-connection attempt ${attempts} failed: ${error.message}`);
                    return false; // Failed
                }
            };
            
            // Try connecting multiple times with delays
            for (let i = 0; i < maxAttempts; i++) {
                const success = await tryConnect();
                if (success) return; // Successfully connected
                
                // Wait before next attempt (unless it's the last attempt)
                if (i < maxAttempts - 1) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
            
            // If we get here, all attempts failed
            debugLog(`âŒ Auto-connection failed after ${maxAttempts} attempts`);
            updateConnectionStatus();
            updateDeviceLists(); // Ensure USB fix box is shown
        }

        // Initialize app
        async function initializeApp() {
            updateConnectionStatus();
            updateButtonStates();
            debugLog('ðŸš€ MIDI Loop Manager initialized');
            
            // Initialize MIDI first
            await initMIDI();
            
            // Try to auto-connect HID after a short delay
            setTimeout(autoConnect, 500);
            
            // Start periodic HID connection monitoring
            startHIDMonitoring();
        }
        
        // Monitor HID connection status periodically
        function startHIDMonitoring() {
            setInterval(async () => {
                // Check if HID device is still connected
                if (hidDevice && isConnected) {
                    try {
                        // Try to check if device is still available
                        const devices = await navigator.hid.getDevices();
                        const deviceStillExists = devices.find(d => d.productId === hidDevice.productId && d.vendorId === hidDevice.vendorId);
                        
                        if (!deviceStillExists) {
                            debugLog('ðŸ”Œ HID device disconnected');
                            isConnected = false;
                            hidDevice = null;
                            updateConnectionStatus();
                            updateDeviceLists(); // Show USB fix box
                            showStatus('MIDIswitch HID disconnected', 'error');
                        }
                    } catch (error) {
                        // Device likely disconnected
                        debugLog('ðŸ”Œ HID device connection lost');
                        isConnected = false;
                        hidDevice = null;
                        updateConnectionStatus();
                        updateDeviceLists(); // Show USB fix box
                    }
                } else if (!isConnected) {
                    // Try to auto-reconnect if not connected
                    try {
                        await autoConnect();
                    } catch (error) {
                        // Silent fail - don't spam the user
                    }
                }
            }, 3000); // Check every 3 seconds
        }
        
        // MIDI Patchbay Functions
        
        // Initialize MIDI with multiple retry attempts
        async function initMIDI() {
            initAttempts++;
            
            try {
                if (!navigator.requestMIDIAccess) {
                    throw new Error('Web MIDI API not supported in this browser');
                }
                
                debugLog(`MIDI initialization attempt ${initAttempts}...`);
                
                // Request MIDI access with all possible options
                const midiOptions = { 
                    sysex: true,
                    software: true
                };
                
                midiAccess = await navigator.requestMIDIAccess(midiOptions);
                debugLog(`MIDI access granted! (Attempt ${initAttempts})`);
                
                // Set up state change listener
                midiAccess.onstatechange = (event) => {
                    debugLog('MIDI state change detected:', event.port.name, event.port.state);
                    setTimeout(updateDeviceLists, 500); // Small delay for stability
                };
                
                // Initial device list update
                updateDeviceLists();
                
                // Schedule multiple refresh attempts to catch slow USB devices
                scheduleUSBDeviceScans();
                
            } catch (error) {
                debugLog(`MIDI initialization attempt ${initAttempts} failed: ${error.message}`);
                
                // Retry initialization if we haven't exceeded max attempts
                if (initAttempts < maxInitAttempts) {
                    setTimeout(() => {
                        debugLog(`Retrying MIDI initialization in 2 seconds...`);
                        initMIDI();
                    }, 2000);
                }
            }
        }
        
        function scheduleUSBDeviceScans() {
            // Multiple scans at different intervals to catch USB devices
            const scanTimes = [1000, 3000, 5000, 8000, 12000]; // Progressive delays
            
            scanTimes.forEach((delay, index) => {
                setTimeout(() => {
                    debugLog(`USB device scan ${index + 1}...`);
                    updateDeviceLists();
                }, delay);
            });
        }
        
        function updateDeviceLists() {
            if (!midiAccess) {
                debugLog('MIDI access not available yet');
                return;
            }
            
            debugLog('=== DEVICE SCAN ===');
            debugLog(`Input ports: ${midiAccess.inputs.size}`);
            debugLog(`Output ports: ${midiAccess.outputs.size}`);
            
            const inputSelect = document.getElementById('inputSelect');
            const statusLight = document.getElementById('statusLight');
            
            // Clear existing content
            inputSelect.innerHTML = '<option value="">Select MIDI Input...</option>';
            
            let midiswitchFound = false;
            midiswitchOutput = null;
            
            // Process inputs - add all to dropdown EXCEPT MIDIswitch (to prevent loops)
            const inputs = Array.from(midiAccess.inputs.values());
            inputs.forEach(input => {
                debugLog(`Input: ${input.name} (ID: ${input.id}, State: ${input.state}, Connection: ${input.connection})`);
                
                // Try to open the port to ensure it's available
                try {
                    if (input.connection === 'closed') {
                        input.open();
                    }
                } catch (e) {
                    debugLog(`Could not open input ${input.name}: ${e.message}`);
                }
                
                // Add to dropdown only if NOT MIDIswitch (prevent feedback loops)
                if (!input.name.toLowerCase().includes('midiswitch')) {
                    const option = document.createElement('option');
                    option.value = input.id;
                    option.textContent = input.name;
                    inputSelect.appendChild(option);
                }
            });
            
            // Process outputs - look for MIDIswitch
            const outputs = Array.from(midiAccess.outputs.values());
            outputs.forEach(output => {
                debugLog(`Output: ${output.name} (ID: ${output.id}, State: ${output.state}, Connection: ${output.connection})`);
                
                // Check if this is a MIDIswitch device
                if (output.name.toLowerCase().includes('midiswitch')) {
                    midiswitchFound = true;
                    midiswitchOutput = output;
                    
                    // Try to open the port to ensure it's available
                    try {
                        if (output.connection === 'closed') {
                            output.open();
                        }
                    } catch (e) {
                        debugLog(`Could not open output ${output.name}: ${e.message}`);
                    }
                }
            });
            
            // Update status light
            if (midiswitchFound && midiswitchOutput) {
                statusLight.className = 'status-light connected';
                // Update HID connection status too
                if (!isConnected) {
                    isConnected = true;
                    updateConnectionStatus();
                }
            } else {
                statusLight.className = 'status-light disconnected';
            }
            
            // Show/hide USB fix section based on whether MIDIswitch was found OR HID not connected
            const usbFixDiv = document.getElementById('usbFix');
            if (midiswitchFound && isConnected) {
                // Both MIDI and HID connected - hide the box
                usbFixDiv.style.display = 'none';
            } else {
                // Either MIDI or HID missing - show the box
                usbFixDiv.style.display = 'block';
                
                // Update the message based on what's missing
                const usbTitle = usbFixDiv.querySelector('h3');
                const usbText = usbFixDiv.querySelector('p');
                
                if (!midiswitchFound) {
                    usbTitle.textContent = 'MIDIswitch Not Detected?';
                    usbText.textContent = 'If your MIDIswitch isn\'t showing up:';
                } else if (!isConnected) {
                    usbTitle.textContent = 'HID Connection Required';
                    usbText.textContent = 'MIDI connected, but HID needed for Loop Manager:';
                }
            }
            
            debugLog('=== END SCAN ===');
        }
        
        // Force refresh functions for USB troubleshooting
        function hardRefresh() {
            debugLog('Hard refresh requested...');
            
            if (midiAccess) {
                // Force all ports to close and reopen
                midiAccess.inputs.forEach(input => {
                    try {
                        input.close();
                        setTimeout(() => input.open(), 100);
                    } catch (e) {}
                });
                
                midiAccess.outputs.forEach(output => {
                    try {
                        output.close();
                        setTimeout(() => output.open(), 100);
                    } catch (e) {}
                });
            }
            
            // Multiple rapid scans
            setTimeout(updateDeviceLists, 500);
            setTimeout(updateDeviceLists, 1500);
            setTimeout(updateDeviceLists, 3000);
        }
        
        function reinitializeMIDI() {
            debugLog('Reinitializing MIDI system...');
            
            // Reset everything
            midiAccess = null;
            initAttempts = 0;
            
            // Clear existing connections
            midiConnections.forEach(conn => {
                try {
                    conn.input.onmidimessage = null;
                } catch (e) {}
            });
            midiConnections = [];
            
            updateMIDIConnectionsList();
            
            // Restart initialization
            setTimeout(initMIDI, 1000);
        }
        
        function addMIDIConnection() {
            const inputSelect = document.getElementById('inputSelect');
            const inputId = inputSelect.value;
            
            if (!inputId) {
                showStatus('Please select a MIDI input device', 'error');
                return;
            }
            
            if (!midiswitchOutput) {
                showStatus('MIDIswitch not detected - please check connection', 'error');
                return;
            }
            
            const existingConnection = midiConnections.find(conn => 
                conn.inputId === inputId && conn.outputId === midiswitchOutput.id
            );
            
            if (existingConnection) {
                showStatus('Connection already exists', 'error');
                return;
            }
            
            const input = midiAccess.inputs.get(inputId);
            
            if (!input) {
                showStatus('Selected input device not found', 'error');
                return;
            }
            
            // Create connection
            const connection = {
                inputId: inputId,
                outputId: midiswitchOutput.id,
                inputName: input.name,
                outputName: midiswitchOutput.name,
                input: input,
                output: midiswitchOutput,
                // Advanced settings
                filterEnabled: false,
                allowedMessageTypes: new Set(),
                channelFilterEnabled: false,
                allowedChannels: new Set(),
                remapEnabled: false,
                remapChannel: 1
            };
            
            // Set up MIDI message forwarding (NO SysEx handling here - that's done by the automatic listener)
            input.onmidimessage = function(event) {
                // Forward messages if they pass filters
                if (!shouldFilterMessage(event.data, connection)) {
                    let data = event.data;
                    
                    // Apply channel remapping if enabled
                    if (connection.remapEnabled && isChannelMessage(data[0])) {
                        data = remapChannel(data, connection.remapChannel);
                    }
                    
                    midiswitchOutput.send(data);
                }
            };
            
            midiConnections.push(connection);
            updateMIDIConnectionsList();
            showStatus(`Connected ${input.name} â†’ ${midiswitchOutput.name}`, 'success');
            
            inputSelect.value = '';
        }
        
        function removeMIDIConnection(index) {
            const connection = midiConnections[index];
            connection.input.onmidimessage = null;
            midiConnections.splice(index, 1);
            updateMIDIConnectionsList();
            showStatus(`Disconnected ${connection.inputName} â†’ ${connection.outputName}`, 'success');
        }
        
        function updateMIDIConnectionsList() {
            const connectionsDiv = document.getElementById('connectionsList');
            
            if (midiConnections.length === 0) {
                connectionsDiv.innerHTML = '';
                return;
            }
            
            // Add title only when there are connections
            let connectionsHTML = '<div class="connections-title">Active MIDI Connections</div>';
            
            midiConnections.forEach((connection, index) => {
                connectionsHTML += `
                    <div class="connection">
                        <div class="connection-header">
                            <div class="connection-info">
                                <span style="font-weight: 500; color: #2d3748;">${connection.inputName}</span>
                                <span class="connection-arrow" style="margin: 0 12px;">â†’</span>
                                <span style="font-weight: 500; color: #2d3748;">${connection.outputName}</span>
                            </div>
                            <div class="connection-buttons">
                                <button class="advanced-btn" onclick="toggleConnectionAdvanced(${index})">Advanced</button>
                                <button onclick="removeMIDIConnection(${index})">Disconnect</button>
                            </div>
                        </div>
                        <div class="connection-advanced" id="connectionAdvanced${index}">
                            <div class="filter-section">
                                <div class="filter-checkbox">
                                    <input type="checkbox" id="filterEnabled${index}" onchange="updateConnectionFilter(${index}, 'filter')" ${connection.filterEnabled ? 'checked' : ''}>
                                    <label for="filterEnabled${index}">Allow these messages only:</label>
                                </div>
                                <div class="message-types">
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('note') ? 'active' : ''}" data-type="note" onclick="toggleConnectionMessageType(${index}, 'note', this)">Note</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('pitch') ? 'active' : ''}" data-type="pitch" onclick="toggleConnectionMessageType(${index}, 'pitch', this)">Pitch</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('aftertouch') ? 'active' : ''}" data-type="aftertouch" onclick="toggleConnectionMessageType(${index}, 'aftertouch', this)">Aftertouch</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('cc') ? 'active' : ''}" data-type="cc" onclick="toggleConnectionMessageType(${index}, 'cc', this)">CC</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('program') ? 'active' : ''}" data-type="program" onclick="toggleConnectionMessageType(${index}, 'program', this)">Prg Chg</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('activesense') ? 'active' : ''}" data-type="activesense" onclick="toggleConnectionMessageType(${index}, 'activesense', this)">Actv Sen</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('reset') ? 'active' : ''}" data-type="reset" onclick="toggleConnectionMessageType(${index}, 'reset', this)">Reset</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('clock') ? 'active' : ''}" data-type="clock" onclick="toggleConnectionMessageType(${index}, 'clock', this)">Clock</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('start') ? 'active' : ''}" data-type="start" onclick="toggleConnectionMessageType(${index}, 'start', this)">Start</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('continue') ? 'active' : ''}" data-type="continue" onclick="toggleConnectionMessageType(${index}, 'continue', this)">Continue</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('stop') ? 'active' : ''}" data-type="stop" onclick="toggleConnectionMessageType(${index}, 'stop', this)">Stop</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('mtc') ? 'active' : ''}" data-type="mtc" onclick="toggleConnectionMessageType(${index}, 'mtc', this)">MTC</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('songpos') ? 'active' : ''}" data-type="songpos" onclick="toggleConnectionMessageType(${index}, 'songpos', this)">Song Pos</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('songsel') ? 'active' : ''}" data-type="songsel" onclick="toggleConnectionMessageType(${index}, 'songsel', this)">Song Sel</button>
                                    <button class="message-type-btn ${connection.allowedMessageTypes.has('tunereq') ? 'active' : ''}" data-type="tunereq" onclick="toggleConnectionMessageType(${index}, 'tunereq', this)">Tune Rq</button>
                                </div>
                            </div>
                            <div class="filter-section">
                                <div class="filter-checkbox">
                                    <input type="checkbox" id="channelFilterEnabled${index}" onchange="updateConnectionFilter(${index}, 'channel')" ${connection.channelFilterEnabled ? 'checked' : ''}>
                                    <label for="channelFilterEnabled${index}">Allow messages from these channels only:</label>
                                </div>
                                <div class="channel-grid">
                                    ${Array.from({length: 16}, (_, i) => {
                                        const channel = i + 1;
                                        const isActive = connection.allowedChannels.has(channel);
                                        return `<button class="channel-btn ${isActive ? 'active' : ''}" data-channel="${channel}" onclick="toggleConnectionChannel(${index}, ${channel}, this)">${channel}</button>`;
                                    }).join('')}
                                </div>
                            </div>
                            <div class="filter-section">
                                <div class="filter-checkbox">
                                    <input type="checkbox" id="remapEnabled${index}" onchange="updateConnectionFilter(${index}, 'remap')" ${connection.remapEnabled ? 'checked' : ''}>
                                    <label for="remapEnabled${index}">Remap to channel:</label>
                                </div>
                                <div class="channel-grid">
                                    ${Array.from({length: 16}, (_, i) => {
                                        const channel = i + 1;
                                        const isActive = connection.remapChannel === channel;
                                        return `<button class="channel-btn ${isActive ? 'active' : ''}" data-remap="${channel}" onclick="selectConnectionRemapChannel(${index}, ${channel}, this)">${channel}</button>`;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            connectionsDiv.innerHTML = connectionsHTML;
        }
        
        // Connection-specific advanced functions
        function toggleConnectionAdvanced(index) {
            const advancedDiv = document.getElementById(`connectionAdvanced${index}`);
            const advancedBtn = event.target;
            
            if (advancedDiv.classList.contains('open')) {
                advancedDiv.classList.remove('open');
                advancedBtn.classList.remove('active');
            } else {
                advancedDiv.classList.add('open');
                advancedBtn.classList.add('active');
            }
        }
        
        function updateConnectionFilter(index, type) {
            const connection = midiConnections[index];
            
            if (type === 'filter') {
                connection.filterEnabled = document.getElementById(`filterEnabled${index}`).checked;
            } else if (type === 'channel') {
                connection.channelFilterEnabled = document.getElementById(`channelFilterEnabled${index}`).checked;
            } else if (type === 'remap') {
                connection.remapEnabled = document.getElementById(`remapEnabled${index}`).checked;
            }
        }
        
        function toggleConnectionMessageType(index, messageType, button) {
            const connection = midiConnections[index];
            
            if (button.classList.contains('active')) {
                button.classList.remove('active');
                connection.allowedMessageTypes.delete(messageType);
            } else {
                button.classList.add('active');
                connection.allowedMessageTypes.add(messageType);
            }
        }
        
        function toggleConnectionChannel(index, channel, button) {
            const connection = midiConnections[index];
            
            if (button.classList.contains('active')) {
                button.classList.remove('active');
                connection.allowedChannels.delete(channel);
            } else {
                button.classList.add('active');
                connection.allowedChannels.add(channel);
            }
        }
        
        function selectConnectionRemapChannel(index, channel, button) {
            const connection = midiConnections[index];
            
            // Remove active class from all remap buttons for this connection
            const remapButtons = button.parentElement.querySelectorAll('.channel-btn');
            remapButtons.forEach(btn => btn.classList.remove('active'));
            
            // Set the selected channel as active
            button.classList.add('active');
            connection.remapChannel = channel;
        }
        
        function getMIDIMessageType(data) {
            const statusByte = data[0];
            
            // System Real-Time Messages (0xF8-0xFF)
            if (statusByte >= 0xF8) {
                switch (statusByte) {
                    case 0xF8: return 'clock';
                    case 0xFA: return 'start';
                    case 0xFB: return 'continue';
                    case 0xFC: return 'stop';
                    case 0xFE: return 'activesense';
                    case 0xFF: return 'reset';
                    default: return 'unknown';
                }
            }
            
            // System Common Messages (0xF0-0xF7)
            if (statusByte >= 0xF0) {
                switch (statusByte) {
                    case 0xF1: return 'mtc';
                    case 0xF2: return 'songpos';
                    case 0xF3: return 'songsel';
                    case 0xF6: return 'tunereq';
                    default: return 'unknown';
                }
            }
            
            // Channel Messages (0x80-0xEF)
            const messageType = (statusByte & 0xF0) >> 4;
            switch (messageType) {
                case 0x8: case 0x9: return 'note'; // Note Off / Note On
                case 0xA: return 'aftertouch'; // Polyphonic Key Pressure
                case 0xB: return 'cc'; // Control Change
                case 0xC: return 'program'; // Program Change
                case 0xD: return 'aftertouch'; // Channel Pressure
                case 0xE: return 'pitch'; // Pitch Bend
                default: return 'unknown';
            }
        }
        
        function isChannelMessage(statusByte) {
            return statusByte >= 0x80 && statusByte <= 0xEF;
        }
        
        function getMessageChannel(statusByte) {
            if (isChannelMessage(statusByte)) {
                return (statusByte & 0x0F) + 1; // Convert from 0-15 to 1-16
            }
            return null;
        }
        
        function remapChannel(data, newChannel) {
            const newData = new Uint8Array(data);
            if (isChannelMessage(data[0])) {
                newData[0] = (data[0] & 0xF0) | ((newChannel - 1) & 0x0F);
            }
            return newData;
        }
        
        function shouldFilterMessage(data, connection) {
            // Check message type filtering
            if (connection.filterEnabled && connection.allowedMessageTypes.size > 0) {
                const messageType = getMIDIMessageType(data);
                if (!connection.allowedMessageTypes.has(messageType)) {
                    return true; // Filter out this message
                }
            }
            
            // Check channel filtering
            if (connection.channelFilterEnabled && connection.allowedChannels.size > 0) {
                const channel = getMessageChannel(data[0]);
                if (channel !== null && !connection.allowedChannels.has(channel)) {
                    return true; // Filter out this message
                }
            }
            
            return false; // Don't filter
        }
        // ThruLoop Modal functions
        function openThruLoopModal() {
            document.getElementById('thruloopModalOverlay').style.display = 'block';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }

        function closeThruLoopModal() {
            document.getElementById('thruloopModalOverlay').style.display = 'none';
            document.body.style.overflow = 'auto'; // Restore scrolling
        }

        // Close modal on Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeThruLoopModal();
				closeKeyboardModal();
            }
        });
// Keyboard Settings Functionality
class KeyboardConfig {
    constructor() {
        this.MANUFACTURER_ID = 0x7D;
        this.SUB_ID = 0x00;
        this.DEVICE_ID = 0x4D;
        
        // Command constants for keyboard settings (0xB6-0xBB range)
        this.HID_CMD_SET_KEYBOARD_CONFIG = 0xB6;            // was 0x50
        this.HID_CMD_GET_KEYBOARD_CONFIG = 0xB7;            // was 0x51
        this.HID_CMD_RESET_KEYBOARD_CONFIG = 0xB8;          // was 0x52
        this.HID_CMD_SAVE_KEYBOARD_SLOT = 0xB9;             // was 0x53
        this.HID_CMD_LOAD_KEYBOARD_SLOT = 0xBA;             // was 0x54
        this.HID_CMD_SET_KEYBOARD_CONFIG_ADVANCED = 0xBB;   // was 0x55
    }

    // Send a HID packet using the existing global HID connection
    async sendPacket(command, data = []) {
        // Use the global hidDevice and isConnected variables
        if (!hidDevice || !isConnected) {
            throw new Error('HID device not connected - use main Connect Device button first');
        }

        try {
            // Use the existing sendHIDPacket function
            await sendHIDPacket(command, 0, 0, data ? new Uint8Array(data) : null);
            console.log(`Keyboard: Sent command 0x${command.toString(16)} with ${data.length} bytes`);
        } catch (error) {
            console.error('Keyboard: Failed to send packet:', error);
            throw error;
        }
    }

// Handle responses from keyboard (this will be called by the main HID handler)
handleResponse(data) {
    const view = new DataView(data.buffer);
    
    if (view.getUint8(0) !== this.MANUFACTURER_ID || 
        view.getUint8(1) !== this.SUB_ID || 
        view.getUint8(2) !== this.DEVICE_ID) {
        return; // Not our packet
    }

    const command = view.getUint8(3);
    const status = view.getUint8(5);

    if (status === 0) {
        console.log(`Keyboard: Command 0x${command.toString(16)} completed successfully`);
    } else {
        console.error(`Keyboard: Command 0x${command.toString(16)} failed with status ${status}`);
    }

    // Handle basic config packet (first packet from load operations)
    if (command === this.HID_CMD_GET_KEYBOARD_CONFIG && status === 0 && data.byteLength >= 32) {
        this.updateKeyboardConfigUIBasic(view);
        console.log('Updated basic keyboard config from first packet');
    }
    
if (command === this.HID_CMD_SET_KEYBOARD_CONFIG_ADVANCED && status === 0 && data.byteLength >= 21) {
    // Check if this is actually config data or just an empty acknowledgment
    // Config data packets have 15 bytes of actual data starting at byte 6
    // Acknowledgment packets are mostly zeros after the header
    
    const hasActualData = Array.from(new Uint8Array(data.buffer, 6, 15)).some(byte => byte !== 0);
    
    if (hasActualData) {
        console.log('Received advanced config packet with actual data:', data.byteLength, 'bytes');
        console.log('Data bytes 6-20:', Array.from(new Uint8Array(data.buffer, 6, 15)).map(b => b.toString()));
        this.updateKeyboardConfigUIAdvanced(view);
        console.log('Updated advanced keyboard config from second packet');
    } else {
        console.log('Received empty acknowledgment for advanced config (not updating UI)');
    }
} else if (command === this.HID_CMD_SET_KEYBOARD_CONFIG_ADVANCED && status === 0) {
    console.log('Received save acknowledgment for advanced config (packet too short, not updating UI)');
}
}

	updateKeyboardConfigUIBasic(view) {
		// Parse the basic settings (packet 1)
		document.getElementById('keyboardVelocitySensitivity').value = view.getInt32(6, true);
		document.getElementById('keyboardCcSensitivity').value = view.getInt32(10, true);
		document.getElementById('keyboardChannelNumber').value = view.getUint8(14);
		document.getElementById('keyboardTransposeNumber').value = view.getInt8(15);
		document.getElementById('keyboardTransposeNumber2').value = view.getInt8(17);
		document.getElementById('keyboardTransposeNumber3').value = view.getInt8(19);
		document.getElementById('keyboardVelocityNumber').value = view.getUint8(21);
		document.getElementById('keyboardVelocityNumber2').value = view.getUint8(22);
		document.getElementById('keyboardVelocityNumber3').value = view.getUint8(23);
		document.getElementById('keyboardRandomVelocityModifier').value = view.getUint8(24);
		document.getElementById('keyboardOledKeyboard').value = view.getInt32(25, true);
		document.getElementById('keyboardSmartChordLight').value = view.getUint8(29);
		document.getElementById('keyboardSmartChordLightMode').value = view.getUint8(30);
		
		console.log('Keyboard: Updated basic keyboard config UI');
	}

	updateKeyboardConfigUIAdvanced(view) {
		// Parse the advanced settings (packet 2)
		document.getElementById('keyboardKeySplitChannel').value = view.getUint8(6);
		document.getElementById('keyboardKeySplit2Channel').value = view.getUint8(7);
		document.getElementById('keyboardKeySplitStatus').value = view.getUint8(8);
		document.getElementById('keyboardKeySplitTransposeStatus').value = view.getUint8(9);
		document.getElementById('keyboardKeySplitVelocityStatus').value = view.getUint8(10);
		document.getElementById('keyboardCustomLayerAnimations').value = view.getUint8(11) ? 'true' : 'false';
		document.getElementById('keyboardUnsyncedMode').value = view.getUint8(12).toString();
		document.getElementById('keyboardSampleMode').value = view.getUint8(13) ? 'true' : 'false';
		document.getElementById('keyboardLoopMessagingEnabled').value = view.getUint8(14) ? 'true' : 'false';
		document.getElementById('keyboardLoopMessagingChannel').value = view.getUint8(15).toString();
		document.getElementById('keyboardSyncMidiMode').value = view.getUint8(16) ? 'true' : 'false';
		document.getElementById('keyboardAlternateRestartMode').value = view.getUint8(17) ? 'true' : 'false';
		document.getElementById('keyboardColorblindMode').value = view.getUint8(18);
		document.getElementById('keyboardCcLoopRecording').value = view.getUint8(19) ? 'true' : 'false';
		document.getElementById('keyboardTrueSustain').value = view.getUint8(20) ? 'true' : 'false';
		
		console.log('Keyboard: Updated advanced keyboard config UI');
	}

    // Save to specific slot
    async saveToSlot(slot) {
        const settings = getKeyboardSettings();
        
        // Pack basic data and send with slot number (only basic packet gets slot for save)
        const basicData = packKeyboardBasicData(settings);
        const basicDataWithSlot = [slot, ...Array.from(new Uint8Array(basicData))];
        await this.sendPacket(this.HID_CMD_SAVE_KEYBOARD_SLOT, basicDataWithSlot);
        
        // Small delay between packets
        await new Promise(resolve => setTimeout(resolve, 50));
        
        // Pack advanced data and send WITHOUT slot number (just set the config)
        const advancedData = packKeyboardAdvancedData(settings);
        await this.sendPacket(this.HID_CMD_SET_KEYBOARD_CONFIG_ADVANCED, Array.from(new Uint8Array(advancedData)));
        
        console.log(`Keyboard: Saved keyboard config to slot ${slot} (2 packets)`);
    }

    // Load from specific slot
    async loadFromSlot(slot) {
        await this.sendPacket(this.HID_CMD_LOAD_KEYBOARD_SLOT, [slot]);
        console.log(`Keyboard: Requested keyboard config from slot ${slot}`);
    }

    // Get current configuration
    async getCurrentConfig() {
        await this.sendPacket(this.HID_CMD_GET_KEYBOARD_CONFIG);
        console.log('Keyboard: Requested current config from keyboard');
    }

    // Reset to defaults
    async resetToDefaults() {
        await this.sendPacket(this.HID_CMD_RESET_KEYBOARD_CONFIG);
        console.log('Keyboard: Reset keyboard config to defaults');
    }

    async sendCurrentSettings() {
        const settings = getKeyboardSettings();
        
        // Pack and send basic settings (packet 1)
        const basicData = packKeyboardBasicData(settings);
        await this.sendPacket(this.HID_CMD_SET_KEYBOARD_CONFIG, Array.from(new Uint8Array(basicData)));
        
        // Small delay between packets
        await new Promise(resolve => setTimeout(resolve, 50));
        
        // Pack and send advanced settings (packet 2)
        const advancedData = packKeyboardAdvancedData(settings);
        await this.sendPacket(this.HID_CMD_SET_KEYBOARD_CONFIG_ADVANCED, Array.from(new Uint8Array(advancedData)));
        
        console.log('Keyboard: Sent current keyboard settings to device (2 packets)');
    }
}

let keyboardConfig = new KeyboardConfig();

// Helper function to get form values - FIXED
function getKeyboardSettings() {
    return {
        velocity_sensitivity: parseInt(document.getElementById('keyboardVelocitySensitivity').value),
        cc_sensitivity: parseInt(document.getElementById('keyboardCcSensitivity').value),
        channel_number: parseInt(document.getElementById('keyboardChannelNumber').value),
        transpose_number: parseInt(document.getElementById('keyboardTransposeNumber').value),
        octave_number: 0, // Not in UI, default to 0
        transpose_number2: parseInt(document.getElementById('keyboardTransposeNumber2').value),
        octave_number2: 0, // Not in UI, default to 0
        transpose_number3: parseInt(document.getElementById('keyboardTransposeNumber3').value),
        octave_number3: 0, // Not in UI, default to 0
        velocity_number: parseInt(document.getElementById('keyboardVelocityNumber').value),
        velocity_number2: parseInt(document.getElementById('keyboardVelocityNumber2').value),
        velocity_number3: parseInt(document.getElementById('keyboardVelocityNumber3').value),
        random_velocity_modifier: parseInt(document.getElementById('keyboardRandomVelocityModifier').value),
        oled_keyboard: parseInt(document.getElementById('keyboardOledKeyboard').value),
        smart_chord_light: parseInt(document.getElementById('keyboardSmartChordLight').value),
        smart_chord_light_mode: parseInt(document.getElementById('keyboardSmartChordLightMode').value),
        
        // Add missing keysplit settings (FIXED: these were missing and causing corruption)
        key_split_channel: parseInt(document.getElementById('keyboardKeySplitChannel').value),
        key_split2_channel: parseInt(document.getElementById('keyboardKeySplit2Channel').value),
        key_split_status: parseInt(document.getElementById('keyboardKeySplitStatus').value),
        key_split_transpose_status: parseInt(document.getElementById('keyboardKeySplitTransposeStatus').value),
        key_split_velocity_status: parseInt(document.getElementById('keyboardKeySplitVelocityStatus').value),
        
        custom_layer_animations_enabled: document.getElementById('keyboardCustomLayerAnimations').value === 'true',
        unsynced_mode_active: parseInt(document.getElementById('keyboardUnsyncedMode').value),
        sample_mode_active: document.getElementById('keyboardSampleMode').value === 'true',
        
        // New loop messaging features
        loop_messaging_enabled: document.getElementById('keyboardLoopMessagingEnabled').value === 'true',
        loop_messaging_channel: parseInt(document.getElementById('keyboardLoopMessagingChannel').value),
        sync_midi_mode: document.getElementById('keyboardSyncMidiMode').value === 'true',
        alternate_restart_mode: document.getElementById('keyboardAlternateRestartMode').value === 'true',
        colorblindmode: parseInt(document.getElementById('keyboardColorblindMode').value),
        cclooprecording: document.getElementById('keyboardCcLoopRecording').value === 'true',
        truesustain: document.getElementById('keyboardTrueSustain').value === 'true'
    };
}

// Helper function to set form values - FIXED
function setKeyboardSettings(settings) {
    document.getElementById('keyboardVelocitySensitivity').value = settings.velocity_sensitivity || 1;
    document.getElementById('keyboardCcSensitivity').value = settings.cc_sensitivity || 1;
    document.getElementById('keyboardChannelNumber').value = settings.channel_number || 0;
    document.getElementById('keyboardTransposeNumber').value = settings.transpose_number || 0;
    document.getElementById('keyboardTransposeNumber2').value = settings.transpose_number2 || 0;
    document.getElementById('keyboardTransposeNumber3').value = settings.transpose_number3 || 0;
    document.getElementById('keyboardVelocityNumber').value = settings.velocity_number || 127;
    document.getElementById('keyboardVelocityNumber2').value = settings.velocity_number2 || 127;
    document.getElementById('keyboardVelocityNumber3').value = settings.velocity_number3 || 127;
    document.getElementById('keyboardRandomVelocityModifier').value = settings.random_velocity_modifier || 0;
    document.getElementById('keyboardOledKeyboard').value = settings.oled_keyboard || 0;
    document.getElementById('keyboardSmartChordLight').value = settings.smart_chord_light || 0;
    document.getElementById('keyboardSmartChordLightMode').value = settings.smart_chord_light_mode || 0;
    
    // Set keysplit settings (FIXED: these were missing)
    document.getElementById('keyboardKeySplitChannel').value = settings.key_split_channel || 0;
    document.getElementById('keyboardKeySplit2Channel').value = settings.key_split2_channel || 0;
    document.getElementById('keyboardKeySplitStatus').value = settings.key_split_status || 0;
    document.getElementById('keyboardKeySplitTransposeStatus').value = settings.key_split_transpose_status || 0;
    document.getElementById('keyboardKeySplitVelocityStatus').value = settings.key_split_velocity_status || 0;
    
    document.getElementById('keyboardCustomLayerAnimations').value = settings.custom_layer_animations_enabled ? 'true' : 'false';
    document.getElementById('keyboardUnsyncedMode').value = settings.unsynced_mode_active || 0;
    document.getElementById('keyboardSampleMode').value = settings.sample_mode_active ? 'true' : 'false';
    
    // Set new loop messaging features
    document.getElementById('keyboardLoopMessagingEnabled').value = settings.loop_messaging_enabled ? 'true' : 'false';
    document.getElementById('keyboardLoopMessagingChannel').value = settings.loop_messaging_channel || 16;
    document.getElementById('keyboardSyncMidiMode').value = settings.sync_midi_mode ? 'true' : 'false';
    document.getElementById('keyboardAlternateRestartMode').value = settings.alternate_restart_mode ? 'true' : 'false';
    document.getElementById('keyboardColorblindMode').value = settings.colorblindmode || 0;
    document.getElementById('keyboardCcLoopRecording').value = settings.cclooprecording ? 'true' : 'false';
    document.getElementById('keyboardTrueSustain').value = settings.truesustain ? 'true' : 'false';
}


// Helper function to pack basic settings data (packet 1 - 26 bytes)
function packKeyboardBasicData(settings) {
    const configData = new ArrayBuffer(26);
    const view = new DataView(configData);
    
    let offset = 0;
    
    // Pack 32-bit integers (little endian)
    view.setInt32(offset, settings.velocity_sensitivity || 1, true); offset += 4;
    view.setInt32(offset, settings.cc_sensitivity || 1, true); offset += 4;
    
    // Pack single bytes
    view.setUint8(offset, settings.channel_number || 0); offset += 1;
    view.setInt8(offset, settings.transpose_number || 0); offset += 1;
    view.setInt8(offset, settings.octave_number || 0); offset += 1;
    view.setInt8(offset, settings.transpose_number2 || 0); offset += 1;
    view.setInt8(offset, settings.octave_number2 || 0); offset += 1;
    view.setInt8(offset, settings.transpose_number3 || 0); offset += 1;
    view.setInt8(offset, settings.octave_number3 || 0); offset += 1;
    view.setUint8(offset, settings.velocity_number || 127); offset += 1;
    view.setUint8(offset, settings.velocity_number2 || 127); offset += 1;
    view.setUint8(offset, settings.velocity_number3 || 127); offset += 1;
    view.setUint8(offset, settings.random_velocity_modifier || 0); offset += 1;
    
    // Pack 32-bit integer for oledkeyboard (FIXED: was 1 byte, now 4 bytes)
    view.setInt32(offset, settings.oled_keyboard || 0, true); offset += 4;
    
    // Pack remaining single bytes
    view.setUint8(offset, settings.smart_chord_light || 0); offset += 1;
    view.setUint8(offset, settings.smart_chord_light_mode || 0); offset += 1;
    
    return configData;
}

// Helper function to pack advanced settings data (packet 2 - 15 bytes)
function packKeyboardAdvancedData(settings) {
    const configData = new ArrayBuffer(15);
    const view = new DataView(configData);
    
    let offset = 0;
    
    // Pack keysplit settings
    view.setUint8(offset, settings.key_split_channel || 0); offset += 1;
    view.setUint8(offset, settings.key_split2_channel || 0); offset += 1;
    view.setUint8(offset, settings.key_split_status || 0); offset += 1;
    view.setUint8(offset, settings.key_split_transpose_status || 0); offset += 1;
    view.setUint8(offset, settings.key_split_velocity_status || 0); offset += 1;
    
    // Pack boolean settings
    view.setUint8(offset, settings.custom_layer_animations_enabled ? 1 : 0); offset += 1;
    view.setUint8(offset, settings.unsynced_mode_active || 0); offset += 1;
    view.setUint8(offset, settings.sample_mode_active ? 1 : 0); offset += 1;
    
    // Pack loop messaging features
    view.setUint8(offset, settings.loop_messaging_enabled ? 1 : 0); offset += 1;
    view.setUint8(offset, settings.loop_messaging_channel || 16); offset += 1;
    view.setUint8(offset, settings.sync_midi_mode ? 1 : 0); offset += 1;
    view.setUint8(offset, settings.alternate_restart_mode ? 1 : 0); offset += 1;
    view.setUint8(offset, settings.colorblindmode || 0); offset += 1;
    view.setUint8(offset, settings.cclooprecording ? 1 : 0); offset += 1;
    view.setUint8(offset, settings.truesustain ? 1 : 0); offset += 1;
    
    return configData;
}

// Helper function to reset UI to defaults - FIXED
function resetKeyboardUIToDefaults() {
    setKeyboardSettings({
        velocity_sensitivity: 1,
        cc_sensitivity: 1,
        channel_number: 0,
        transpose_number: 0,
        transpose_number2: 0,
        transpose_number3: 0,
        velocity_number: 127,
        velocity_number2: 127,
        velocity_number3: 127,
        random_velocity_modifier: 0,
        oled_keyboard: 0,
        smart_chord_light: 0,
        smart_chord_light_mode: 0,
        
        // Add missing keysplit defaults (FIXED: these were missing)
        key_split_channel: 0,
        key_split2_channel: 0,
        key_split_status: 0,
        key_split_transpose_status: 0,
        key_split_velocity_status: 0,
        
        custom_layer_animations_enabled: false,
        unsynced_mode_active: 0,
        sample_mode_active: false,
        
        // New loop messaging features defaults
        loop_messaging_enabled: false,
        loop_messaging_channel: 16,
        sync_midi_mode: false,
        alternate_restart_mode: false,
        colorblindmode: 0,
        cclooprecording: false,
        truesustain: false
    });
}

// Helper function to show status message for keyboard settings - FIXED
function showKeyboardStatus(message, isSuccess = true) {
    const status = document.getElementById('keyboardSendStatus');
    status.textContent = message;
    status.className = `keyboard-status ${isSuccess ? 'success' : 'error'}`;
    status.style.display = 'block';
    
    // Hide after 3 seconds
    setTimeout(() => {
        status.style.display = 'none';
    }, 3000);
}

// Function to get current keyboard configuration
function getCurrentKeyboardConfig() {
    return {
        version: "1.0",
        settings: getKeyboardSettings()
    };
}

// Function to apply keyboard configuration
function applyKeyboardConfig(config) {
    if (config.settings) {
        setKeyboardSettings(config.settings);
    }
}

// Function to save keyboard configuration to file
function saveKeyboardConfigToFile() {
    const config = getCurrentKeyboardConfig();
    const json = JSON.stringify(config, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'keyboard-settings.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Function to load keyboard configuration from file
function loadKeyboardConfigFromFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const config = JSON.parse(e.target.result);
                applyKeyboardConfig(config);
                resolve();
            } catch (error) {
                reject(new Error('Invalid configuration file'));
            }
        };
        reader.onerror = function() {
            reject(new Error('Failed to read file'));
        };
        reader.readAsText(file);
    });
}

// Keyboard Settings Modal functions
function openKeyboardModal() {
    document.getElementById('keyboardModalOverlay').style.display = 'block';
    document.body.style.overflow = 'hidden'; // Prevent background scrolling
}

function closeKeyboardModal() {
    document.getElementById('keyboardModalOverlay').style.display = 'none';
    document.body.style.overflow = 'auto'; // Restore scrolling
}

// Initialize keyboard settings event listeners - FIXED
function initializeKeyboardSettings() {
    // Save to slot button handlers
    for (let i = 0; i < 5; i++) {
        const saveBtn = document.getElementById(`keyboardSaveSlot${i}Btn`);
        if (saveBtn) {
            saveBtn.addEventListener('click', async () => {
                try {
                    await keyboardConfig.saveToSlot(i);
                    const slotName = i === 0 ? 'default settings' : `Slot ${i}`;
                    showKeyboardStatus(`Saved as ${slotName}`, true);
                } catch (error) {
                    showKeyboardStatus(`Failed to save to slot ${i}: ` + error.message, false);
                }
            });
        }
    }

    // Load from slot button handlers
    for (let i = 0; i < 5; i++) {
        const loadBtn = document.getElementById(`keyboardLoadSlot${i}Btn`);
        if (loadBtn) {
            loadBtn.addEventListener('click', async () => {
                try {
                    await keyboardConfig.loadFromSlot(i);
                    // Small delay to ensure both packets are processed
                    await new Promise(resolve => setTimeout(resolve, 100));
                    const slotName = i === 0 ? 'default settings' : `Slot ${i}`;
                    showKeyboardStatus(`Loaded ${slotName}`, true);
                } catch (error) {
                    showKeyboardStatus(`Failed to load from slot ${i}: ` + error.message, false);
                }
            });
        }
    }

    // Save to file button handler
    const saveFileBtn = document.getElementById('keyboardSaveFileBtn');
    if (saveFileBtn) {
        saveFileBtn.addEventListener('click', () => {
            try {
                saveKeyboardConfigToFile();
                showKeyboardStatus('Settings saved to file', true);
            } catch (error) {
                showKeyboardStatus('Failed to save to file: ' + error.message, false);
            }
        });
    }

    // Load from file button handler
    const loadFileBtn = document.getElementById('keyboardLoadFileBtn');
    if (loadFileBtn) {
        loadFileBtn.addEventListener('click', () => {
            document.getElementById('keyboardFileInput').click();
        });
    }

    // File input change handler
    const fileInput = document.getElementById('keyboardFileInput');
    if (fileInput) {
        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            try {
                await loadKeyboardConfigFromFile(file);
                showKeyboardStatus('Settings loaded from file', true);
            } catch (error) {
                showKeyboardStatus('Failed to load from file: Invalid format', false);
            }
            
            // Clear the file input
            event.target.value = '';
        });
    }

    // Send current settings button handler (NOT IMPLEMENTED IN HTML YET)
    const sendBtn = document.getElementById('keyboardSendAllBtn');
    if (sendBtn) {
        sendBtn.addEventListener('click', async () => {
            try {
                await keyboardConfig.sendCurrentSettings();
                showKeyboardStatus('Settings sent to keyboard successfully!', true);
            } catch (error) {
                showKeyboardStatus('Failed to send settings: ' + error.message, false);
            }
        });
    }

	// Load from keyboard button handler (NOT IMPLEMENTED IN HTML YET)
		const loadBtn = document.getElementById('keyboardLoadBtn');
		if (loadBtn) {
			loadBtn.addEventListener('click', async () => {
				try {
					await keyboardConfig.getCurrentConfig();
					// Small delay to ensure both packets are processed
					await new Promise(resolve => setTimeout(resolve, 100));
					showKeyboardStatus('Settings loaded from keyboard', true);
				} catch (error) {
					showKeyboardStatus('Failed to load from keyboard: ' + error.message, false);
				}
			});
		}
	
	const resetBtn = document.getElementById('keyboardResetBtn');
if (resetBtn) {
    resetBtn.addEventListener('click', async () => {
        const confirmed = confirm('Reset all keyboard settings to defaults? This cannot be undone.');
        if (!confirmed) return;

        try {
            await keyboardConfig.resetToDefaults();
            resetKeyboardUIToDefaults(); // Update UI immediately
            showKeyboardStatus('Settings reset to defaults', true);
        } catch (error) {
            showKeyboardStatus('Failed to reset settings: ' + error.message, false);
        }
    });
}

    console.log('Keyboard Settings initialized');
}
// ThruLoop functionality - FIXED VERSION
class ThruLoopConfig {
    constructor() {
        this.MANUFACTURER_ID = 0x7D;
        this.SUB_ID = 0x00;
        this.DEVICE_ID = 0x4D;
        
        // Command constants (0xB0-0xB5 range)
        this.HID_CMD_SET_LOOP_CONFIG = 0xB0;        // was 0x40
        this.HID_CMD_SET_MAIN_LOOP_CCS = 0xB1;      // was 0x41
        this.HID_CMD_SET_OVERDUB_CCS = 0xB2;        // was 0x42
        this.HID_CMD_SET_NAVIGATION_CONFIG = 0xB3;  // was 0x43
        this.HID_CMD_GET_ALL_CONFIG = 0xB4;         // was 0x44
        this.HID_CMD_RESET_LOOP_CONFIG = 0xB5;      // was 0x45
    }

    // Remove the connect method - we'll use the global connection
    
    // Send a HID packet using the existing global HID connection
    async sendPacket(command, macroNum, data = []) {
        // Use the global hidDevice and isConnected variables
        if (!hidDevice || !isConnected) {
            throw new Error('HID device not connected - use main Connect Device button first');
        }

        const packet = new Uint8Array(32);
        packet[0] = this.MANUFACTURER_ID;
        packet[1] = this.SUB_ID;
        packet[2] = this.DEVICE_ID;
        packet[3] = command;
        packet[4] = macroNum;
        packet[5] = 0; // Status

        // Copy data payload
        for (let i = 0; i < data.length && i < 26; i++) {
            packet[6 + i] = data[i];
        }

        try {
            // Use the existing sendHIDPacket function instead of duplicating the logic
            await sendHIDPacket(command, macroNum, 0, data ? new Uint8Array(data) : null);
            console.log(`ThruLoop: Sent command 0x${command.toString(16)} with ${data.length} bytes`);
        } catch (error) {
            console.error('ThruLoop: Failed to send packet:', error);
            throw error;
        }
    }

    // Handle responses from keyboard (this will be called by the main HID handler)
    handleResponse(data) {
        const view = new DataView(data.buffer);
        
        if (view.getUint8(0) !== this.MANUFACTURER_ID || 
            view.getUint8(1) !== this.SUB_ID || 
            view.getUint8(2) !== this.DEVICE_ID) {
            return; // Not our packet
        }

        const command = view.getUint8(3);
        const macroNum = view.getUint8(4);
        const status = view.getUint8(5);

        if (status === 0) {
            console.log(`ThruLoop: Command 0x${command.toString(16)} completed successfully`);
        } else {
            console.error(`ThruLoop: Command 0x${command.toString(16)} failed with status ${status}`);
        }

        // Handle config data responses for "Load from Keyboard"
        if (command === this.HID_CMD_SET_LOOP_CONFIG && status === 0 && data.byteLength >= 14) {
            this.updateLoopConfigUI(view);
        } else if (command === this.HID_CMD_SET_MAIN_LOOP_CCS && status === 0 && data.byteLength >= 26) {
            this.updateMainLoopCCsUI(view);
        } else if (command === this.HID_CMD_SET_OVERDUB_CCS && status === 0 && data.byteLength >= 26) {
            this.updateOverdubCCsUI(view);
        } else if (command === this.HID_CMD_SET_NAVIGATION_CONFIG && status === 0 && data.byteLength >= 16) {
            this.updateNavigationConfigUI(view);
        }
    }

    // Update UI with received loop configuration
    updateLoopConfigUI(view) {
        document.getElementById('thruloopLoopEnabled').checked = view.getUint8(6) === 0; // Reversed: 0 from device = checked (disabled UI)
        document.getElementById('thruloopLoopChannel').value = view.getUint8(7);
        document.getElementById('thruloopSyncMidi').checked = view.getUint8(8) !== 0;
        document.getElementById('thruloopAlternateRestart').checked = view.getUint8(9) !== 0;
		document.getElementById('thruloopCcLoopRecording').checked = view.getUint8(14) !== 0;
        updateThruLoopCCInput('thruloopRestart1', view.getUint8(10));
        updateThruLoopCCInput('thruloopRestart2', view.getUint8(11));
        updateThruLoopCCInput('thruloopRestart3', view.getUint8(12));
        updateThruLoopCCInput('thruloopRestart4', view.getUint8(13));
        
        toggleThruLoopSections(); // Update the UI sections
        console.log('ThruLoop: Updated loop config UI');
    }

    // Update UI with received main loop CCs
    updateMainLoopCCsUI(view) {
        // Start recording CCs
        updateThruLoopCCInput('thruloopMainStartRec1', view.getUint8(6));
        updateThruLoopCCInput('thruloopMainStartRec2', view.getUint8(7));
        updateThruLoopCCInput('thruloopMainStartRec3', view.getUint8(8));
        updateThruLoopCCInput('thruloopMainStartRec4', view.getUint8(9));
        
        // Stop recording CCs
        updateThruLoopCCInput('thruloopMainStopRec1', view.getUint8(10));
        updateThruLoopCCInput('thruloopMainStopRec2', view.getUint8(11));
        updateThruLoopCCInput('thruloopMainStopRec3', view.getUint8(12));
        updateThruLoopCCInput('thruloopMainStopRec4', view.getUint8(13));
        
        // Start playing CCs
        updateThruLoopCCInput('thruloopMainStartPlay1', view.getUint8(14));
        updateThruLoopCCInput('thruloopMainStartPlay2', view.getUint8(15));
        updateThruLoopCCInput('thruloopMainStartPlay3', view.getUint8(16));
        updateThruLoopCCInput('thruloopMainStartPlay4', view.getUint8(17));
        
        // Stop playing CCs
        updateThruLoopCCInput('thruloopMainStopPlay1', view.getUint8(18));
        updateThruLoopCCInput('thruloopMainStopPlay2', view.getUint8(19));
        updateThruLoopCCInput('thruloopMainStopPlay3', view.getUint8(20));
        updateThruLoopCCInput('thruloopMainStopPlay4', view.getUint8(21));
        
        // Clear CCs
        updateThruLoopCCInput('thruloopMainClear1', view.getUint8(22));
        updateThruLoopCCInput('thruloopMainClear2', view.getUint8(23));
        updateThruLoopCCInput('thruloopMainClear3', view.getUint8(24));
        updateThruLoopCCInput('thruloopMainClear4', view.getUint8(25));
        
        console.log('ThruLoop: Updated main loop CCs UI');
    }

    // Update UI with received overdub CCs
    updateOverdubCCsUI(view) {
        // Start recording CCs
        updateThruLoopCCInput('thruloopOverdubStartRec1', view.getUint8(6));
        updateThruLoopCCInput('thruloopOverdubStartRec2', view.getUint8(7));
        updateThruLoopCCInput('thruloopOverdubStartRec3', view.getUint8(8));
        updateThruLoopCCInput('thruloopOverdubStartRec4', view.getUint8(9));
        
        // Stop recording CCs
        updateThruLoopCCInput('thruloopOverdubStopRec1', view.getUint8(10));
        updateThruLoopCCInput('thruloopOverdubStopRec2', view.getUint8(11));
        updateThruLoopCCInput('thruloopOverdubStopRec3', view.getUint8(12));
        updateThruLoopCCInput('thruloopOverdubStopRec4', view.getUint8(13));
        
        // Start playing CCs
        updateThruLoopCCInput('thruloopOverdubStartPlay1', view.getUint8(14));
        updateThruLoopCCInput('thruloopOverdubStartPlay2', view.getUint8(15));
        updateThruLoopCCInput('thruloopOverdubStartPlay3', view.getUint8(16));
        updateThruLoopCCInput('thruloopOverdubStartPlay4', view.getUint8(17));
        
        // Stop playing CCs
        updateThruLoopCCInput('thruloopOverdubStopPlay1', view.getUint8(18));
        updateThruLoopCCInput('thruloopOverdubStopPlay2', view.getUint8(19));
        updateThruLoopCCInput('thruloopOverdubStopPlay3', view.getUint8(20));
        updateThruLoopCCInput('thruloopOverdubStopPlay4', view.getUint8(21));
        
        // Clear CCs
        updateThruLoopCCInput('thruloopOverdubClear1', view.getUint8(22));
        updateThruLoopCCInput('thruloopOverdubClear2', view.getUint8(23));
        updateThruLoopCCInput('thruloopOverdubClear3', view.getUint8(24));
        updateThruLoopCCInput('thruloopOverdubClear4', view.getUint8(25));
        
        console.log('ThruLoop: Updated overdub CCs UI');
    }

    // Update UI with received navigation configuration
    updateNavigationConfigUI(view) {
        document.getElementById('thruloopSeparateLoopChopCC').checked = view.getUint8(6) !== 0;
        updateThruLoopCCInput('thruloopMasterCC', view.getUint8(7));
        
        updateThruLoopCCInput('thruloopNav0', view.getUint8(8));
        updateThruLoopCCInput('thruloopNav1', view.getUint8(9));
        updateThruLoopCCInput('thruloopNav2', view.getUint8(10));
        updateThruLoopCCInput('thruloopNav3', view.getUint8(11));
        updateThruLoopCCInput('thruloopNav4', view.getUint8(12));
        updateThruLoopCCInput('thruloopNav5', view.getUint8(13));
        updateThruLoopCCInput('thruloopNav6', view.getUint8(14));
        updateThruLoopCCInput('thruloopNav7', view.getUint8(15));
        
        toggleThruLoopChop(); // Update the LoopChop display
        console.log('ThruLoop: Updated navigation config UI');
    }

    // Request all configuration from keyboard
    async loadAllConfig() {
        await this.sendPacket(this.HID_CMD_GET_ALL_CONFIG, 0);
        console.log('ThruLoop: Requested all config from keyboard');
    }

    // Reset all configuration to defaults
    async resetConfig() {
        await this.sendPacket(this.HID_CMD_RESET_LOOP_CONFIG, 0);
        console.log('ThruLoop: Reset all config to defaults');
    }
}
        
        let thruloopConfig = new ThruLoopConfig();
        
        // Helper function to create CC dropdown options
        function createThruLoopCCOptions() {
            let options = '<option value="128">None</option>';
            for (let i = 0; i <= 127; i++) {
                options += `<option value="${i}">CC# ${i}</option>`;
            }
            return options;
        }
        
        // Helper function to initialize all CC dropdowns
        function initializeThruLoopCCDropdowns() {
            const ccSelects = document.querySelectorAll('.thruloop-cc-select');
            const optionsHTML = createThruLoopCCOptions();
            
            ccSelects.forEach(select => {
                select.innerHTML = optionsHTML;
                select.value = '128'; // Default to "None"
            });
        }
        
        // Helper function to toggle sections based on ThruLoop enabled state
        // NOTE: Logic is REVERSED - when checkbox is checked, UI is disabled
        function toggleThruLoopSections() {
            const enabled = document.getElementById('thruloopLoopEnabled').checked;
            const mainSection = document.getElementById('thruloopMainSection');
            const overlay = document.getElementById('thruloopDisabledOverlay');
            const syncMidi = document.getElementById('thruloopSyncMidi');
            const alternateRestart = document.getElementById('thruloopAlternateRestart');
            const loopChannel = document.getElementById('thruloopLoopChannel');
            const channelLabel = document.querySelector('.thruloop-channel-label');
            
            if (!enabled) {  // When UNchecked, enable everything
                mainSection.classList.remove('thruloop-disabled-section');
                overlay.style.display = 'none';
                syncMidi.disabled = false;
                alternateRestart.disabled = false;
                loopChannel.disabled = false;
                syncMidi.parentElement.style.opacity = '1';
                alternateRestart.parentElement.style.opacity = '1';
                loopChannel.style.opacity = '1';
                channelLabel.style.opacity = '1';
            } else {  // When checked, disable everything
                mainSection.classList.add('thruloop-disabled-section');
                overlay.style.display = 'block';
                syncMidi.disabled = true;
                alternateRestart.disabled = true;
                loopChannel.disabled = true;
                syncMidi.parentElement.style.opacity = '0.2';
                alternateRestart.parentElement.style.opacity = '0.2';
                loopChannel.style.opacity = '0.2';
                channelLabel.style.opacity = '0.2';
            }
        }
        
        // Helper function to toggle LoopChop display
        function toggleThruLoopChop() {
            const separateCC = document.getElementById('thruloopSeparateLoopChopCC').checked;
            const singleSection = document.getElementById('thruloopLoopchopSingle');
            const tableSection = document.getElementById('thruloopLoopchopTable');
            
            if (separateCC) {
                singleSection.style.display = 'none';
                tableSection.style.display = 'table';
            } else {
                singleSection.style.display = 'table';
                tableSection.style.display = 'none';
            }
        }
        
        // Helper function to update CC dropdown display
        function updateThruLoopCCInput(id, value) {
            const select = document.getElementById(id);
            select.value = value.toString();
        }
        
        // Helper function to get CC value from dropdown
        function getThruLoopCCValue(id) {
            const select = document.getElementById(id);
            return parseInt(select.value);
        }
        
        // Helper function to reset UI to defaults
        function resetThruLoopUIToDefaults() {
            document.getElementById('thruloopLoopEnabled').checked = false; // Unchecked = enabled with reversed logic
            document.getElementById('thruloopLoopChannel').value = '16';
            document.getElementById('thruloopSyncMidi').checked = false;
            document.getElementById('thruloopAlternateRestart').checked = false;
            document.getElementById('thruloopSeparateLoopChopCC').checked = false;
            document.getElementById('thruloopCcLoopRecording').checked = false;
            // Reset all CC selects to 128 (None)
            const ccSelects = document.querySelectorAll('.thruloop-cc-select');
            ccSelects.forEach(select => {
                select.value = '128';
            });
            
            toggleThruLoopChop(); // Update LoopChop display
            toggleThruLoopSections(); // Update sections display
        }
        
        // Function to get current configuration
        function getCurrentThruLoopConfig() {
            return {
                version: "1.0",
                loopEnabled: !document.getElementById('thruloopLoopEnabled').checked, // Reversed logic for file saving
                loopChannel: parseInt(document.getElementById('thruloopLoopChannel').value),
                syncMidi: document.getElementById('thruloopSyncMidi').checked,
                alternateRestart: document.getElementById('thruloopAlternateRestart').checked,
                separateLoopChopCC: document.getElementById('thruloopSeparateLoopChopCC').checked,
                ccLoopRecording: document.getElementById('thruloopCcLoopRecording').checked,
                // Restart CCs
                restart1: getThruLoopCCValue('thruloopRestart1'),
                restart2: getThruLoopCCValue('thruloopRestart2'),
                restart3: getThruLoopCCValue('thruloopRestart3'),
                restart4: getThruLoopCCValue('thruloopRestart4'),
                
                // Main Loop CCs
                mainStartRec1: getThruLoopCCValue('thruloopMainStartRec1'),
                mainStartRec2: getThruLoopCCValue('thruloopMainStartRec2'),
                mainStartRec3: getThruLoopCCValue('thruloopMainStartRec3'),
                mainStartRec4: getThruLoopCCValue('thruloopMainStartRec4'),
                mainStopRec1: getThruLoopCCValue('thruloopMainStopRec1'),
                mainStopRec2: getThruLoopCCValue('thruloopMainStopRec2'),
                mainStopRec3: getThruLoopCCValue('thruloopMainStopRec3'),
                mainStopRec4: getThruLoopCCValue('thruloopMainStopRec4'),
                mainStartPlay1: getThruLoopCCValue('thruloopMainStartPlay1'),
                mainStartPlay2: getThruLoopCCValue('thruloopMainStartPlay2'),
                mainStartPlay3: getThruLoopCCValue('thruloopMainStartPlay3'),
                mainStartPlay4: getThruLoopCCValue('thruloopMainStartPlay4'),
                mainStopPlay1: getThruLoopCCValue('thruloopMainStopPlay1'),
                mainStopPlay2: getThruLoopCCValue('thruloopMainStopPlay2'),
                mainStopPlay3: getThruLoopCCValue('thruloopMainStopPlay3'),
                mainStopPlay4: getThruLoopCCValue('thruloopMainStopPlay4'),
                mainClear1: getThruLoopCCValue('thruloopMainClear1'),
                mainClear2: getThruLoopCCValue('thruloopMainClear2'),
                mainClear3: getThruLoopCCValue('thruloopMainClear3'),
                mainClear4: getThruLoopCCValue('thruloopMainClear4'),
                
                // Overdub CCs
                overdubStartRec1: getThruLoopCCValue('thruloopOverdubStartRec1'),
                overdubStartRec2: getThruLoopCCValue('thruloopOverdubStartRec2'),
                overdubStartRec3: getThruLoopCCValue('thruloopOverdubStartRec3'),
                overdubStartRec4: getThruLoopCCValue('thruloopOverdubStartRec4'),
                overdubStopRec1: getThruLoopCCValue('thruloopOverdubStopRec1'),
                overdubStopRec2: getThruLoopCCValue('thruloopOverdubStopRec2'),
                overdubStopRec3: getThruLoopCCValue('thruloopOverdubStopRec3'),
                overdubStopRec4: getThruLoopCCValue('thruloopOverdubStopRec4'),
                overdubStartPlay1: getThruLoopCCValue('thruloopOverdubStartPlay1'),
                overdubStartPlay2: getThruLoopCCValue('thruloopOverdubStartPlay2'),
                overdubStartPlay3: getThruLoopCCValue('thruloopOverdubStartPlay3'),
                overdubStartPlay4: getThruLoopCCValue('thruloopOverdubStartPlay4'),
                overdubStopPlay1: getThruLoopCCValue('thruloopOverdubStopPlay1'),
                overdubStopPlay2: getThruLoopCCValue('thruloopOverdubStopPlay2'),
                overdubStopPlay3: getThruLoopCCValue('thruloopOverdubStopPlay3'),
                overdubStopPlay4: getThruLoopCCValue('thruloopOverdubStopPlay4'),
                overdubClear1: getThruLoopCCValue('thruloopOverdubClear1'),
                overdubClear2: getThruLoopCCValue('thruloopOverdubClear2'),
                overdubClear3: getThruLoopCCValue('thruloopOverdubClear3'),
                overdubClear4: getThruLoopCCValue('thruloopOverdubClear4'),
                
                // Navigation CCs
                masterCC: getThruLoopCCValue('thruloopMasterCC'),
                nav0: getThruLoopCCValue('thruloopNav0'),
                nav1: getThruLoopCCValue('thruloopNav1'),
                nav2: getThruLoopCCValue('thruloopNav2'),
                nav3: getThruLoopCCValue('thruloopNav3'),
                nav4: getThruLoopCCValue('thruloopNav4'),
                nav5: getThruLoopCCValue('thruloopNav5'),
                nav6: getThruLoopCCValue('thruloopNav6'),
                nav7: getThruLoopCCValue('thruloopNav7')
				
				
            };
        }
        
        // Function to apply configuration
        function applyThruLoopConfig(config) {
            document.getElementById('thruloopLoopEnabled').checked = !config.loopEnabled; // Reversed logic
            document.getElementById('thruloopLoopChannel').value = config.loopChannel;
            document.getElementById('thruloopSyncMidi').checked = config.syncMidi;
            document.getElementById('thruloopAlternateRestart').checked = config.alternateRestart;
            document.getElementById('thruloopSeparateLoopChopCC').checked = config.separateLoopChopCC;
            document.getElementById('thruloopCcLoopRecording').checked = config.ccLoopRecording;
            // Apply all CC values
            Object.keys(config).forEach(key => {
                if (key !== 'version' && key !== 'loopEnabled' && key !== 'loopChannel' && 
                    key !== 'syncMidi' && key !== 'alternateRestart' && key !== 'separateLoopChopCC') {
                    updateThruLoopCCInput('thruloop' + key.charAt(0).toUpperCase() + key.slice(1), config[key]);
                }
            });
            
            toggleThruLoopSections();
            toggleThruLoopChop();
        }
        
        // Function to save configuration to file
        function saveThruLoopConfigToFile() {
            const config = getCurrentThruLoopConfig();
            const json = JSON.stringify(config, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'thruloop-config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Function to load configuration from file
        function loadThruLoopConfigFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const config = JSON.parse(e.target.result);
                        applyThruLoopConfig(config);
                        resolve();
                    } catch (error) {
                        reject(new Error('Invalid configuration file'));
                    }
                };
                reader.onerror = function() {
                    reject(new Error('Failed to read file'));
                };
                reader.readAsText(file);
            });
        }

        // Initialize ThruLoop on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeThruLoopCCDropdowns(); // Initialize all CC dropdowns
            resetThruLoopUIToDefaults();
            toggleThruLoopSections(); // Set initial state based on checkbox
            toggleThruLoopChop(); // Set initial LoopChop display
            
            // Add event listeners
            document.getElementById('thruloopLoopEnabled').addEventListener('change', toggleThruLoopSections);
            document.getElementById('thruloopSeparateLoopChopCC').addEventListener('change', toggleThruLoopChop);
            
            console.log('ThruLoop Configuration Modal initialized');
        });
        
        // Add event listeners for all the buttons
        document.getElementById('thruloopSendAllBtn').addEventListener('click', async () => {
            const status = document.getElementById('thruloopSendStatus');
            const btn = document.getElementById('thruloopSendAllBtn');
            
            btn.disabled = true;
            btn.textContent = 'Saving...';
            
            try {
                // 1. Send basic loop configuration (HID_CMD_SET_LOOP_CONFIG = 0x40)
			const loopConfigData = [
				document.getElementById('thruloopLoopEnabled').checked ? 0 : 1,
				parseInt(document.getElementById('thruloopLoopChannel').value),
				document.getElementById('thruloopSyncMidi').checked ? 1 : 0,
				document.getElementById('thruloopAlternateRestart').checked ? 1 : 0,
				getThruLoopCCValue('thruloopRestart1'),
				getThruLoopCCValue('thruloopRestart2'),
				getThruLoopCCValue('thruloopRestart3'),
				getThruLoopCCValue('thruloopRestart4'),
				document.getElementById('thruloopCcLoopRecording').checked ? 1 : 0  // Add this line
			];
                await thruloopConfig.sendPacket(thruloopConfig.HID_CMD_SET_LOOP_CONFIG, 0, loopConfigData);
                console.log('Sent loop config');
                
                // Small delay between packets
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // 2. Send main loop CCs (HID_CMD_SET_MAIN_LOOP_CCS = 0x41)
                const mainLoopData = [
                    // Start recording CCs (4 values)
                    getThruLoopCCValue('thruloopMainStartRec1'),
                    getThruLoopCCValue('thruloopMainStartRec2'),
                    getThruLoopCCValue('thruloopMainStartRec3'),
                    getThruLoopCCValue('thruloopMainStartRec4'),
                    // Stop recording CCs (4 values)
                    getThruLoopCCValue('thruloopMainStopRec1'),
                    getThruLoopCCValue('thruloopMainStopRec2'),
                    getThruLoopCCValue('thruloopMainStopRec3'),
                    getThruLoopCCValue('thruloopMainStopRec4'),
                    // Start playing CCs (4 values)
                    getThruLoopCCValue('thruloopMainStartPlay1'),
                    getThruLoopCCValue('thruloopMainStartPlay2'),
                    getThruLoopCCValue('thruloopMainStartPlay3'),
                    getThruLoopCCValue('thruloopMainStartPlay4'),
                    // Stop playing CCs (4 values)
                    getThruLoopCCValue('thruloopMainStopPlay1'),
                    getThruLoopCCValue('thruloopMainStopPlay2'),
                    getThruLoopCCValue('thruloopMainStopPlay3'),
                    getThruLoopCCValue('thruloopMainStopPlay4'),
                    // Clear CCs (4 values)
                    getThruLoopCCValue('thruloopMainClear1'),
                    getThruLoopCCValue('thruloopMainClear2'),
                    getThruLoopCCValue('thruloopMainClear3'),
                    getThruLoopCCValue('thruloopMainClear4')
                ];
                await thruloopConfig.sendPacket(thruloopConfig.HID_CMD_SET_MAIN_LOOP_CCS, 0, mainLoopData);
                console.log('Sent main loop CCs');
                
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // 3. Send overdub CCs (HID_CMD_SET_OVERDUB_CCS = 0x42)
                const overdubData = [
                    // Start recording CCs (4 values)
                    getThruLoopCCValue('thruloopOverdubStartRec1'),
                    getThruLoopCCValue('thruloopOverdubStartRec2'),
                    getThruLoopCCValue('thruloopOverdubStartRec3'),
                    getThruLoopCCValue('thruloopOverdubStartRec4'),
                    // Stop recording CCs (4 values)
                    getThruLoopCCValue('thruloopOverdubStopRec1'),
                    getThruLoopCCValue('thruloopOverdubStopRec2'),
                    getThruLoopCCValue('thruloopOverdubStopRec3'),
                    getThruLoopCCValue('thruloopOverdubStopRec4'),
                    // Start playing CCs (4 values)
                    getThruLoopCCValue('thruloopOverdubStartPlay1'),
                    getThruLoopCCValue('thruloopOverdubStartPlay2'),
                    getThruLoopCCValue('thruloopOverdubStartPlay3'),
                    getThruLoopCCValue('thruloopOverdubStartPlay4'),
                    // Stop playing CCs (4 values)
                    getThruLoopCCValue('thruloopOverdubStopPlay1'),
                    getThruLoopCCValue('thruloopOverdubStopPlay2'),
                    getThruLoopCCValue('thruloopOverdubStopPlay3'),
                    getThruLoopCCValue('thruloopOverdubStopPlay4'),
                    // Clear CCs (4 values)
                    getThruLoopCCValue('thruloopOverdubClear1'),
                    getThruLoopCCValue('thruloopOverdubClear2'),
                    getThruLoopCCValue('thruloopOverdubClear3'),
                    getThruLoopCCValue('thruloopOverdubClear4')
                ];
                await thruloopConfig.sendPacket(thruloopConfig.HID_CMD_SET_OVERDUB_CCS, 0, overdubData);
                console.log('Sent overdub CCs');
                
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // 4. Send navigation configuration (HID_CMD_SET_NAVIGATION_CONFIG = 0x43)
                const navigationData = [
                    document.getElementById('thruloopSeparateLoopChopCC').checked ? 1 : 0,
                    getThruLoopCCValue('thruloopMasterCC'),
                    getThruLoopCCValue('thruloopNav0'),
                    getThruLoopCCValue('thruloopNav1'),
                    getThruLoopCCValue('thruloopNav2'),
                    getThruLoopCCValue('thruloopNav3'),
                    getThruLoopCCValue('thruloopNav4'),
                    getThruLoopCCValue('thruloopNav5'),
                    getThruLoopCCValue('thruloopNav6'),
                    getThruLoopCCValue('thruloopNav7')
                ];
                await thruloopConfig.sendPacket(thruloopConfig.HID_CMD_SET_NAVIGATION_CONFIG, 0, navigationData);
                console.log('Sent navigation config');
                
                status.textContent = 'Configuration saved successfully!';
                status.className = 'thruloop-status success';
                status.style.display = 'block';
                
                btn.disabled = false;
                btn.textContent = 'Save Configuration';
                
            } catch (error) {
                status.textContent = 'Failed to save configuration: ' + error.message;
                status.className = 'thruloop-status error';
                status.style.display = 'block';
                
                btn.disabled = false;
                btn.textContent = 'Save Configuration';
            }
        });
        
        // Save to File button handler
        document.getElementById('thruloopSaveFileBtn').addEventListener('click', () => {
            try {
                saveThruLoopConfigToFile();
                
                const status = document.getElementById('thruloopSendStatus');
                status.textContent = 'Configuration saved to file!';
                status.className = 'thruloop-status success';
                status.style.display = 'block';
                
            } catch (error) {
                const status = document.getElementById('thruloopSendStatus');
                status.textContent = 'Failed to save file: ' + error.message;
                status.className = 'thruloop-status error';
                status.style.display = 'block';
            }
        });
        
        // Load from File button handler
        document.getElementById('thruloopLoadFileBtn').addEventListener('click', () => {
            document.getElementById('thruloopLoadFileInput').click();
        });
        
        // File input change handler
        document.getElementById('thruloopLoadFileInput').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                await loadThruLoopConfigFromFile(file);
                
                const status = document.getElementById('thruloopSendStatus');
                status.textContent = 'Configuration loaded from file!';
                status.className = 'thruloop-status success';
                status.style.display = 'block';
                
            } catch (error) {
                const status = document.getElementById('thruloopSendStatus');
                status.textContent = 'Failed to load file: ' + error.message;
                status.className = 'thruloop-status error';
                status.style.display = 'block';
            }
            
            // Clear the file input so the same file can be selected again
            event.target.value = '';
        });
        
        // Load from Keyboard button handler
        document.getElementById('thruloopLoadBtn').addEventListener('click', async () => {
            try {
                await thruloopConfig.loadAllConfig();
                console.log('Load request sent - waiting for response...');
                
                const status = document.getElementById('thruloopSendStatus');
                status.textContent = 'Load request sent - check console for responses';
                status.className = 'thruloop-status success';
                status.style.display = 'block';
                
            } catch (error) {
                console.error('Failed to load config:', error);
                
                const status = document.getElementById('thruloopSendStatus');
                status.textContent = 'Failed to load configuration: ' + error.message;
                status.className = 'thruloop-status error';
                status.style.display = 'block';
            }
        });
        // Start the app
        initializeApp();
		        // Initialize ThruLoop after the main app
        setTimeout(() => {
            initializeThruLoopCCDropdowns();
            resetThruLoopUIToDefaults();
            toggleThruLoopSections();
            toggleThruLoopChop();
            
            // Add event listeners
            document.getElementById('thruloopLoopEnabled').addEventListener('change', toggleThruLoopSections);
            document.getElementById('thruloopSeparateLoopChopCC').addEventListener('change', toggleThruLoopChop);
            
            console.log('ThruLoop Configuration integrated and initialized');
        }, 100);
		// Initialize keyboard settings after the main app
		setTimeout(() => {
			resetKeyboardUIToDefaults();
			initializeKeyboardSettings();
			console.log('Keyboard Settings integrated and initialized');
		}, 100);
    </script>
</body>
</html>