# Logarithmic vs Linear ADC-to-Distance Conversion

## Overview

This document compares libhmk's **logarithmic lookup table (LUT)** approach for ADC-to-distance conversion with the current orthomidi5x14 **linear normalization** approach. This is intended as a reference for potential future migration.

---

## The Problem: Non-Linear Hall Effect Sensors

Hall effect sensors produce ADC readings that don't map linearly to physical position:

```
Physical Position (mm)    Hall Effect ADC Response
─────────────────────    ────────────────────────
0.0mm (rest)             High sensitivity zone
0.5mm                    ↑ Large ADC changes
1.0mm                    │ for small movements
1.5mm (typical actuation)│
2.0mm                    ↓ Lower sensitivity zone
2.5mm (bottom-out)       Small ADC changes
```

This non-linearity means:
- **Near rest**: Small physical movements cause large ADC changes
- **Near bottom**: Large physical movements cause small ADC changes

---

## Current Implementation: Linear Normalization

### orthomidi5x14 Approach

```c
// Simple linear mapping: 0-100 scale (0-2.5mm)
uint8_t travel = (raw_adc - rest) * 100 / (bottom - rest);
```

Or for 0-255 scale:
```c
uint8_t distance = (raw_adc - rest) * 255 / (bottom - rest);
```

### Visual Representation

```
ADC Value (raw sensor reading)
     │
4095 ┤                          ╱ bottom-out
     │                        ╱
     │                      ╱
     │                    ╱
     │                  ╱
     │                ╱
     │              ╱
     │            ╱
     │          ╱
     │        ╱
     │      ╱
     │    ╱
     │  ╱
3000 ┤╱ rest
     └──────────────────────────────
     0                            255
                Distance (output)

Result: Constant slope - each unit of distance
        requires the same ADC change everywhere
```

### Characteristics

| Aspect | Linear Approach |
|--------|-----------------|
| **Complexity** | Very simple (one division) |
| **Memory** | Zero additional memory |
| **CPU cycles** | ~10-20 cycles |
| **Precision** | Equal everywhere |
| **Predictability** | Very intuitive (50 = 1.25mm) |

### Advantages

1. **Simplicity**: One-line calculation
2. **Zero memory overhead**: No lookup table needed
3. **Intuitive**: Users understand "50 = half travel"
4. **MIDI-friendly**: Linear velocity mapping makes sense for music

### Disadvantages

1. **Wasted resolution**: High precision where you don't need it (near bottom)
2. **Reduced precision**: Lower precision near actuation point where it matters most
3. **Ignores sensor characteristics**: Doesn't compensate for Hall sensor non-linearity

---

## libhmk Implementation: Logarithmic LUT

### Approach

libhmk uses a 1024-entry pre-computed lookup table with logarithmic scaling:

```c
// Generated by tools/distance_lut.py
static const uint8_t distance_lut[1024] = {
    0, 3, 6, 9, 12, 14, 17, 19, 22, 24, ...
    // 1024 entries mapping normalized ADC to distance
};

static inline uint8_t adc_to_distance(uint16_t adc,
                                       uint16_t rest,
                                       uint16_t bottom_out) {
    // Edge cases
    if (adc <= rest) return 0;
    if (adc >= bottom_out) return 255;
    if (rest >= bottom_out) return 0;  // Invalid calibration

    // Normalize to 0-1023 range
    uint32_t normalized = ((uint32_t)(adc - rest) * 1023) / (bottom_out - rest);

    // Lookup
    return distance_lut[normalized];
}
```

### LUT Generation Formula

```python
# From libhmk/tools/distance_lut.py
# Formula: distance = 255 * log(1 + a*x) / log(1 + a*1023)

import math

LUT_SIZE = 1024
a = 0.01  # Tuning constant (sensor-specific)

lut = []
for i in range(LUT_SIZE):
    x = i  # Normalized ADC value (0-1023)
    if x == 0:
        distance = 0
    else:
        distance = int(255 * math.log(1 + a * x) / math.log(1 + a * 1023))
    lut.append(distance)
```

### Visual Representation

```
ADC Value (raw sensor reading)
     │
4095 ┤                          ─── bottom-out
     │                       ──╱
     │                    ──╱
     │                 ──╱
     │              ──╱
     │           ──╱
     │        ──╱
     │      ─╱
     │    ─╱
     │   ╱
     │  ╱
     │ ╱
     │╱
3000 ┤ rest
     └──────────────────────────────
     0   32  64  96 128         255
                Distance (output)

Result: Steeper slope near rest (more resolution),
        flatter slope near bottom (less resolution)
```

### Characteristics

| Aspect | Logarithmic LUT |
|--------|-----------------|
| **Complexity** | Normalization + table lookup |
| **Memory** | 1KB (1024 bytes) |
| **CPU cycles** | ~20-30 cycles |
| **Precision** | Concentrated near rest/actuation |
| **Predictability** | Non-intuitive (32 ≠ 0.8mm) |

### Advantages

1. **Better actuation precision**: More resolution where rapid trigger needs it
2. **Compensates for sensor**: Matches Hall sensor output characteristics
3. **Faster at boundaries**: Edge case handling avoids lookup
4. **Tunable**: Adjust `a` constant per sensor type

### Disadvantages

1. **Memory cost**: 1KB flash for lookup table
2. **Less intuitive**: Distance values don't map linearly to mm
3. **Sensor-specific**: Needs recalibration per switch/sensor combination
4. **Harder to debug**: Non-obvious relationship between ADC and distance

---

## Side-by-Side Comparison

### Resolution Distribution

```
Distance   Linear Resolution    Log LUT Resolution
────────   ──────────────────   ──────────────────
0-32       ~32 ADC steps        ~64 ADC steps (2x)
32-64      ~32 ADC steps        ~48 ADC steps (1.5x)
64-128     ~64 ADC steps        ~64 ADC steps (1x)
128-255    ~127 ADC steps       ~80 ADC steps (0.6x)
```

The logarithmic LUT provides **2x resolution** near rest position and actuation point, at the cost of reduced resolution near bottom-out.

### Gaming Impact

| Scenario | Linear | Logarithmic | Winner |
|----------|--------|-------------|--------|
| Rapid trigger near actuation | Good | Better | Log |
| Rapid trigger near bottom | Better | Good | Linear |
| Consistent feel | Better | Varies by position | Linear |
| Competitive gaming | Good | Better | Log |

### MIDI/Music Impact

| Scenario | Linear | Logarithmic | Winner |
|----------|--------|-------------|--------|
| Predictable velocity | Better | Less predictable | Linear |
| Velocity curves | Works as expected | May need adjustment | Linear |
| User understanding | Intuitive | Confusing | Linear |
| Fine control at light touch | Good | Better | Log |

---

## Implementation Considerations

### If Migrating to Logarithmic LUT

1. **Generate sensor-specific LUT**:
   ```python
   # Calibrate with your specific Hall sensors
   # GEON Raw HE + OH49E-S uses a ≈ 0.01
   # Your sensors may need different value
   ```

2. **Add LUT to firmware**:
   ```c
   // In a new file: distance_lut.h
   static const uint8_t distance_lut[1024] PROGMEM = {
       // Generated values...
   };
   ```

3. **Update conversion function**:
   ```c
   static inline uint8_t adc_to_distance(uint16_t adc,
                                          uint16_t rest,
                                          uint16_t bottom_out) {
       if (adc <= rest) return 0;
       if (adc >= bottom_out) return 255;
       if (rest >= bottom_out) return 0;

       uint32_t normalized = ((uint32_t)(adc - rest) * 1023) / (bottom_out - rest);
       return pgm_read_byte(&distance_lut[normalized]);
   }
   ```

4. **Update velocity curves** (if using):
   - Curves designed for linear input may need adjustment
   - Consider keeping linear for MIDI, log for gaming

### Hybrid Approach Option

You could use **both** approaches:
- **Logarithmic** for rapid trigger processing (gaming performance)
- **Linear** for MIDI velocity calculation (predictability)

```c
// For rapid trigger
uint8_t rt_distance = adc_to_distance_log(adc, rest, bottom);

// For MIDI velocity
uint8_t midi_travel = adc_to_distance_linear(adc, rest, bottom);
```

---

## Memory and Performance Impact

### Current (Linear)

```
Code size: ~20 bytes
RAM usage: 0 bytes
Per-key computation: ~15 cycles
```

### Logarithmic LUT

```
Code size: ~40 bytes
Flash usage: 1,024 bytes (LUT)
RAM usage: 0 bytes (LUT in PROGMEM)
Per-key computation: ~25 cycles
```

### Impact on 70-key Matrix

```
Linear:     70 × 15 = 1,050 cycles per scan
Logarithmic: 70 × 25 = 1,750 cycles per scan
Difference: +700 cycles (~0.1ms at 8MHz)
```

The difference is negligible for practical use.

---

## Recommendation

### For orthomidi5x14 (MIDI + Gaming Hybrid)

**Keep linear for now** because:
1. MIDI velocity benefits from predictable linear mapping
2. Your velocity curves are designed for linear input
3. Rapid trigger already works well with current implementation
4. Memory is at a premium with all your features

### Consider logarithmic if:
1. Users report rapid trigger feels "mushy" near actuation
2. You want to match competitive gaming keyboard feel
3. You have 1KB flash to spare
4. You're willing to adjust velocity curves

### Potential Future Enhancement

Add a **compile-time option**:
```c
#ifdef USE_LOGARITHMIC_LUT
    #include "distance_lut.h"
    #define adc_to_distance adc_to_distance_log
#else
    #define adc_to_distance adc_to_distance_linear
#endif
```

This would allow users to choose based on their preference.

---

## References

- libhmk source: https://github.com/peppapighs/libhmk
- libhmk distance.h: Contains the LUT and conversion function
- libhmk tools/distance_lut.py: Python script to generate calibrated LUT
- Desmos calculator: Used for curve fitting validation (referenced in libhmk comments)

---

## Appendix: Sample LUT Values

First 64 entries of a typical logarithmic LUT (a = 0.01):

```
Index:  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
Value:  0   3   6   9  12  14  17  19  22  24  26  28  30  32  34  36

Index: 16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
Value: 38  40  41  43  45  46  48  49  51  52  54  55  57  58  59  61

Index: 32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47
Value: 62  63  65  66  67  68  70  71  72  73  74  75  77  78  79  80

Index: 48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63
Value: 81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96
```

Notice how early indices (near rest) have larger value jumps (0→3→6→9), while later indices have smaller jumps. This concentrates precision where it matters most for actuation detection.
